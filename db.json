{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.git","hash":"042ff34da0707513a5681580b37513c890c671ef","modified":1537429362784},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1537429362788},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1537429362792},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1537429362788},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1537429362788},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1537429362788},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1537429362792},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1537429362792},{"_id":"themes/next/README.md","hash":"c1d6d1c6b75736b892e179865833ea58da5ca9d2","modified":1537429362792},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1537429362792},{"_id":"themes/next/bower.json","hash":"5391684ba84fe633bc7877ab711a7d8a0072ceda","modified":1537429362792},{"_id":"themes/next/package.json","hash":"9acf6b8c8194f8a366025c8aab64d236908e62a1","modified":1537429362800},{"_id":"themes/next/_config.yml","hash":"9bf8dda858f7a3fde572efb42e68f7b7983edcfb","modified":1537539372504},{"_id":"source/_posts/2018-9-21校内测试.md","hash":"05d2ea532279700eafae8d325119e8932303da9b","modified":1537537657230},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1537400287000},{"_id":"source/_posts/perf.md","hash":"118a8806b4ee2c82ea5f32488254a064843d109b","modified":1537571867540},{"_id":"source/about/index.md","hash":"c29925bb0860f3d5de59d95d5ffb044a310d46bf","modified":1537538794706},{"_id":"source/tags/index.md","hash":"c97edadcff37012ab8ff7b22af5acc597d9b334a","modified":1537411603000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1537429362788},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1537429362792},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1537429362792},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1537429362792},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1537429362792},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1537429362792},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1537429362792},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1537429362792},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1537429362792},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1537429362792},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1537429362792},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1537429362792},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1537429362792},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1537429362792},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1537429362792},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1537429362792},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1537429362792},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1537429362792},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1537429362792},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1537429362792},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1537429362792},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1537429362792},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1537429362792},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1537429362792},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1537429362792},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1537429362792},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1537429362792},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1537429362796},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1537429362796},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1537429362796},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1537429362796},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1537429362796},{"_id":"themes/next/layout/_layout.swig","hash":"1b59036ccb2ad571503b94587f458fad46775642","modified":1537429362796},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1537429362800},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1537429362800},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1537429362800},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1537429362800},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1537429362800},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1537429362800},{"_id":"themes/next/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1537429362800},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1537429362800},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1537429362800},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1537429362800},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1537429362792},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1537429362812},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1537429362812},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"source/_posts/perf/SA.pdf.svg","hash":"630f4968c3d342faf95ae3152c40d6e74c89f5df","modified":1537572049926},{"_id":"source/_posts/perf/SA_suffix_links.pdf.svg","hash":"35d994b1687fd48e8797b61729fb592569cd54b8","modified":1537572049954},{"_id":"source/_posts/perf/SAa.pdf.svg","hash":"390eff874aeaab9e5dba811ef2e8f0d8acdcf2da","modified":1537572050014},{"_id":"source/_posts/perf/SAaa.pdf.svg","hash":"96b3fe8ae1f603b90dc9377cb8e8778a01da724b","modified":1537572051958},{"_id":"source/_posts/perf/SAab.pdf.svg","hash":"b3c819f8bfa5f1820e0b69ca394953592513029f","modified":1537572053930},{"_id":"source/_posts/perf/SAaba.pdf.svg","hash":"bb95d4c5076cd0e1cf9e324ac6bbd8e09734b107","modified":1537572053950},{"_id":"source/_posts/perf/SAabb.pdf.svg","hash":"4a326ab6f268ca90d86fc618b7b8c13190bd290a","modified":1537572053974},{"_id":"source/_posts/perf/SAabbb.pdf.svg","hash":"425cc1171ecac6ad4acd30e3b39652a2f7251249","modified":1537572053994},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1537429362812},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1537429362792},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1537429362792},{"_id":"themes/next/docs/ru/README.md","hash":"edfe0cfb8b2c9f0effd3beb868af9bfd0fabb3a6","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1537429362792},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1537429362792},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1537429362792},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1537429362796},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1537429362796},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1537429362796},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1537429362796},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1537429362796},{"_id":"themes/next/layout/_macro/post.swig","hash":"27922af64ecb9db9a28bcf1c98fb68b26bf0b67a","modified":1537429362796},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1537429362796},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1537429362796},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1537429362796},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1537429362796},{"_id":"themes/next/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1537429362796},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1537429362796},{"_id":"themes/next/layout/_partials/footer.swig","hash":"05cdaf9b6cb32afd442b228cd247aaf9468a31ed","modified":1537429362796},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1537429362796},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1537429362796},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1537429362796},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1537429362796},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1537429362796},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1537429362796},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1537429362796},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1537429362796},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1537429362796},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1537429362796},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1537429362796},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1537429362796},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1537429362800},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1537429362800},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1537429362800},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1537429362800},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1537429362800},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1537429362800},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1537429362800},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1537429362800},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1537429362800},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1537429362800},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1537429362800},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1537429362800},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1537429362804},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1537429362804},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1537429362804},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1537429362804},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1537429362804},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1537429362804},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1537429362804},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1537429362804},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1537429362804},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1537429362804},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1537429362804},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1537429362804},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1537429362804},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537429362804},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1537429362804},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537429362804},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1537429362808},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1537429362808},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1537429362808},{"_id":"source/_posts/2018-9-21校内测试/pro.pdf","hash":"9b6e156514121225dc3b8dd8e94e5779e46be70d","modified":1537537158684},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362796},{"_id":"themes/next/docs/zh-CN/README.md","hash":"46b264623af21211a0a9c4ba0cf1318a80eeb9fb","modified":1537429362792},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362796},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1537429362792},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1537429362792},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537429362804},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1537429362796},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1537429362796},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1537429362796},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1537429362796},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1537429362796},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1537429362796},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1537429362796},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1537429362796},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1537429362796},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1537429362796},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1537429362796},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1537429362796},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1537429362796},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1537429362796},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1537429362796},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1537429362796},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1537429362796},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1537429362796},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1537429362796},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1537429362796},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1537429362796},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1537429362796},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1537429362796},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1537429362796},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1537429362800},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1537429362800},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1537429362800},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1537429362800},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1537429362804},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1537429362804},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1537429362804},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"51c2907e5c50c2614419b670fbdec183ae7f7f5d","modified":1537429362804},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1537429362804},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1537429362804},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1537429362804},{"_id":"themes/next/source/css/_variables/base.styl","hash":"0b43ddd92e395342703550f629699c5e591fd68b","modified":1537429362804},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1537429362808},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1537429362808},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1537429362808},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1537429362808},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1537429362808},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1537429362808},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1537429362808},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1537429362808},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1537429362808},{"_id":"themes/next/source/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1537429362808},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1537429362812},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1537429362812},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1537429362812},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1537429362812},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1537429362800},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1537429362800},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1537429362804},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1537429362804},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"86c9976f517da4574495372da33e03b95b2a5d52","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1537429362808},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1537429362812},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1537429362812},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1537429362808},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1537429362812},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1537429362812},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"ed9608d2740a33664eb703f806c218a4fc520087","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1537429362800},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"cf2185a0ea170fd8450f592e859a6c941141e5ee","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1537429362804},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1537429362804},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1537429362804},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1537429362808},{"_id":"public/atom.xml","hash":"2218619a59c994f40b69f202c728f038d451889b","modified":1537572192823},{"_id":"public/about/index.html","hash":"1e269c9302ea309e5736cbfbb167afae0708e242","modified":1537572192836},{"_id":"public/tags/index.html","hash":"522de4fe35dab2549462ded07a0b012d6c6eb4c6","modified":1537572192836},{"_id":"public/archives/index.html","hash":"5a8891931c15d7ff72ca88af2d4b57c2aea91e83","modified":1537572192836},{"_id":"public/archives/2018/index.html","hash":"38be958cce94e9a78abe030f673802201b8420f4","modified":1537572192836},{"_id":"public/archives/2018/09/index.html","hash":"6cb23cd182c756d32b03073e508f4e8bcda94021","modified":1537572192836},{"_id":"public/tags/校内测试/index.html","hash":"29b6e5c114ab64a4ff6bdc39ef32b5fadc33431f","modified":1537572192836},{"_id":"public/2018/09/21/perf/index.html","hash":"7741a0931a9a32f0d37528f222a24f5f30d8e7f4","modified":1537572192836},{"_id":"public/2018/09/21/2018-9-21校内测试/index.html","hash":"e2c2b87d0369b93ea361d2d17d71255b0f294efe","modified":1537572192837},{"_id":"public/2018/09/20/hello-world/index.html","hash":"70f59b227104315d3a79412428ff75986c2dd600","modified":1537572192837},{"_id":"public/index.html","hash":"db9a480c2c501183e01523575c8ecd3b37465744","modified":1537572192837},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1537572192843},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1537572192843},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1537572192844},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1537572192844},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1537572192844},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1537572192844},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1537572192844},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1537572192844},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1537572192844},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1537572192844},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1537572192844},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1537572192844},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537572192844},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1537572192844},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537572192845},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1537572192845},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1537572192845},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1537572192845},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1537572192845},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1537572192845},{"_id":"public/2018/09/21/perf/SA.pdf.svg","hash":"630f4968c3d342faf95ae3152c40d6e74c89f5df","modified":1537572192845},{"_id":"public/2018/09/21/perf/SA_suffix_links.pdf.svg","hash":"35d994b1687fd48e8797b61729fb592569cd54b8","modified":1537572192845},{"_id":"public/2018/09/21/perf/SAa.pdf.svg","hash":"390eff874aeaab9e5dba811ef2e8f0d8acdcf2da","modified":1537572192845},{"_id":"public/2018/09/21/perf/SAaa.pdf.svg","hash":"96b3fe8ae1f603b90dc9377cb8e8778a01da724b","modified":1537572192845},{"_id":"public/2018/09/21/perf/SAab.pdf.svg","hash":"b3c819f8bfa5f1820e0b69ca394953592513029f","modified":1537572192845},{"_id":"public/2018/09/21/perf/SAaba.pdf.svg","hash":"bb95d4c5076cd0e1cf9e324ac6bbd8e09734b107","modified":1537572192845},{"_id":"public/2018/09/21/perf/SAabb.pdf.svg","hash":"4a326ab6f268ca90d86fc618b7b8c13190bd290a","modified":1537572192846},{"_id":"public/2018/09/21/perf/SAabbb.pdf.svg","hash":"425cc1171ecac6ad4acd30e3b39652a2f7251249","modified":1537572192846},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1537572193556},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1537572193560},{"_id":"public/2018/09/21/2018-9-21校内测试/pro.pdf","hash":"9b6e156514121225dc3b8dd8e94e5779e46be70d","modified":1537572193562},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1537572193628},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1537572193628},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1537572193629},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1537572193629},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1537572193629},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1537572193629},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1537572193629},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1537572193629},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1537572193629},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1537572193629},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1537572193629},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1537572193629},{"_id":"public/js/src/schemes/pisces.js","hash":"86c9976f517da4574495372da33e03b95b2a5d52","modified":1537572193629},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1537572193629},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1537572193630},{"_id":"public/css/main.css","hash":"0a46e88669285095c8448af723463dc2f108fd93","modified":1537572193630},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1537572193630},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1537572193630},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1537572193630},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1537572193630},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1537572193630},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1537572193630},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1537572193630}],"Category":[],"Data":[],"Page":[{"title":"关于","date":"2018-09-20T01:48:56.000Z","type":"about","comments":0,"_content":"\n**本蒟蒻来自 GRYZ ~~弱省弱校 dalao 们应该没听过~~**\n\n高二狗\n\n> QQ : 1369639556\n>\n> Luogu ID : 奔波儿霸\n>\n> Email : wlz15263859383@gmail.com\\1369639556@qq.com\n>\n> 我的博客圆 : [Mystical-W](https://www.cnblogs.com/bljfy)\n\n这个 blog 的建造过程几经波折，重建了得有 3、4 遍，太不容易了。\n\n要感谢 [MingqiHuang](https://github.com/MingqiHuang) 的帮助 QAQ。\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-09-20 09:48:56\ntype: \"about\"\ncomments: false\n---\n\n**本蒟蒻来自 GRYZ ~~弱省弱校 dalao 们应该没听过~~**\n\n高二狗\n\n> QQ : 1369639556\n>\n> Luogu ID : 奔波儿霸\n>\n> Email : wlz15263859383@gmail.com\\1369639556@qq.com\n>\n> 我的博客圆 : [Mystical-W](https://www.cnblogs.com/bljfy)\n\n这个 blog 的建造过程几经波折，重建了得有 3、4 遍，太不容易了。\n\n要感谢 [MingqiHuang](https://github.com/MingqiHuang) 的帮助 QAQ。\n\n","updated":"2018-09-21T14:06:34.706Z","path":"about/index.html","layout":"page","_id":"cjmcms7j70001ns10e4l11iwa","content":"<p><strong>本蒟蒻来自 GRYZ <del>弱省弱校 dalao 们应该没听过</del></strong></p>\n<p>高二狗</p>\n<blockquote>\n<p>QQ : 1369639556</p>\n<p>Luogu ID : 奔波儿霸</p>\n<p>Email : <a href=\"mailto:wlz15263859383@gmail.com\" target=\"_blank\" rel=\"noopener\">wlz15263859383@gmail.com</a>\\<a href=\"mailto:1369639556@qq.com\" target=\"_blank\" rel=\"noopener\">1369639556@qq.com</a></p>\n<p>我的博客圆 : <a href=\"https://www.cnblogs.com/bljfy\" target=\"_blank\" rel=\"noopener\">Mystical-W</a></p>\n</blockquote>\n<p>这个 blog 的建造过程几经波折，重建了得有 3、4 遍，太不容易了。</p>\n<p>要感谢 <a href=\"https://github.com/MingqiHuang\" target=\"_blank\" rel=\"noopener\">MingqiHuang</a> 的帮助 QAQ。</p>\n","site":{"data":{}},"excerpt":"本蒟蒻来自 GRYZ 弱省弱校 dalao 们应该没听过\n\n高二狗\n\nQQ : 1369639556\n\nLuogu ID : 奔波儿霸\n\nEmail : wlz15263859383@gmail.com\\1369639556@qq.com\n\n我的博客圆 : Mystical-W\n\n这个 blog 的建造过程几经波折，重建了得有 3、4 遍，太不容易了。\n\n要感谢 MingqiHuang 的帮助 QAQ。","more":"<p><strong>本蒟蒻来自 GRYZ <del>弱省弱校 dalao 们应该没听过</del></strong></p>\n<p>高二狗</p>\n<blockquote>\n<p>QQ : 1369639556</p>\n<p>Luogu ID : 奔波儿霸</p>\n<p>Email : <a href=\"mailto:wlz15263859383@gmail.com\" target=\"_blank\" rel=\"noopener\">wlz15263859383@gmail.com</a>\\<a href=\"mailto:1369639556@qq.com\" target=\"_blank\" rel=\"noopener\">1369639556@qq.com</a></p>\n<p>我的博客圆 : <a href=\"https://www.cnblogs.com/bljfy\" target=\"_blank\" rel=\"noopener\">Mystical-W</a></p>\n</blockquote>\n<p>这个 blog 的建造过程几经波折，重建了得有 3、4 遍，太不容易了。</p>\n<p>要感谢 <a href=\"https://github.com/MingqiHuang\" target=\"_blank\" rel=\"noopener\">MingqiHuang</a> 的帮助 QAQ。</p>\n"},{"title":"标签","date":"2018-09-20T01:49:02.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-09-20 09:49:02\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-09-20T02:46:43.000Z","path":"tags/index.html","layout":"page","_id":"cjmcms7jc0003ns104czfcfos","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018.9.21校内测试","date":"2018-09-21T13:36:42.000Z","mathjax":true,"_content":"\n{% pdf ./pro.pdf %}\n\n### 解题报告---9.21\n\n---\n\n\n\n#### $\\text{T1}$ 相遇\n\n---\n\n\n\n##### 反思\n\n---\n\nT1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。\n\n\n\n##### 解题思路\n\n---\n\n画几个图会发现 $a\\rightarrow b,c\\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\\text{LCA}$ 在另两个点之间的路径上。\n\n而一个点 $x$ 在一条路径 $s\\rightarrow t$ 上的充要条件是如下：\n\n- $depth[\\text{LCA}(s,t)]\\le depth[x]$\n- $\\text{LCA}(x,s)=x \\ ||\\  \\text{LCA}(x,t)=x$\n\n然后我们就可以做 $\\text{LCA}$ 进行求解，一组数据最多询问 $4$ 次。\n\n\n\n##### 代码\n\n---\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst int maxn = 2e5+3;\nint n, head[maxn], cnt, depth[maxn], T, fa[maxn][32], m;\nstruct edge {\n\tint to, nxt;\n}ed[maxn], tmp;\nstruct P100 {\n\tinline void reset() {\n\t\tcnt = 0;\n\t\ttmp.to = tmp.nxt = 0;\n\t\tfill(ed+1, ed+1+maxn-3, tmp);\n\t\tmemset(head, 0, sizeof(head));\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(fa, 0, sizeof(fa));\n\t}\n\tinline void addedge(int x, int y) {\n\t\ted[++cnt].nxt = head[x], head[x] = cnt, ed[cnt].to = y;\n\t\ted[++cnt].nxt = head[y], head[y] = cnt, ed[cnt].to = x;\n\t}\n\tinline void init() {\n\t\tfor(int j=1; 1<<j<=n; j++)\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tfa[i][j] = fa[fa[i][j-1]][j-1];\n\t}\n\tinline void dfs(int u) {\n\t\tfor(int i=head[u]; i; i=ed[i].nxt) {\n\t\t\tif(ed[i].to == fa[u][0]) continue;\n\t\t\tfa[ed[i].to][0] = u;\n\t\t\tdepth[ed[i].to] = depth[u] + 1;\n\t\t\tdfs(ed[i].to);\n\t\t}\n\t}\n\tinline int lca(int a, int b) {\n\t\tif(depth[a] > depth[b]) swap(a, b);\n\t\tint h = depth[b] - depth[a];\n\t\tfor(int i=0; 1<<i<=h; i++)\n\t\t\tif((1<<i)&h) b = fa[b][i];\n\t\tif(a != b) {\n\t\t\tfor(int i=(int)log2(n); i>=0; i--) {\n\t\t\t\tif(fa[a][i] != fa[b][i])\n\t\t\t\t\ta = fa[a][i], b = fa[b][i];\n\t\t\t}\n\t\t\ta = fa[a][0];\n\t\t}\n\t\treturn a;\n\t}\n\tinline void solve() {\n\t\tdfs(1);\n\t\tinit();\n\t}\n\tinline bool judge(int a, int b, int c, int d) {\n\t\tint x = lca(a, b), y = lca(c, d);\n\t\tif(depth[x] < depth[y]) swap(x, y), swap(a, c), swap(b, d);\n\t\tif(lca(x, c) == x || lca(x, d) == x) return true;\n\t\treturn false;\n\t}\n}p100;\nint main() {\n\tfreopen(\"railway.in\", \"r\", stdin);\n\tfreopen(\"railway.out\", \"w\", stdout);\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tp100.reset();\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tint x, y;\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp100.addedge(x, y);\n\t\t}\n\t\tp100.solve();\n\t\tint a, b, c, d;\n\t\tfor(int i=1; i<=m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\tif(p100.judge(a, b, c, d)) printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n\n\n\n\n\n#### $\\text{T2}$ 计数\n\n---\n\n\n\n##### 反思\n\n---\n\n不开 `long long` 见祖宗，写了个 $60$ 分的暴力，因为没开 `long long` 所以 WA 成了 30 分，以后做题先看好数据范围，可以为了以防万一，能开 `long long` 就开 `long long` 。\n\n\n\n##### 解题思路\n\n---\n\n在考场上写了个线段树维护区间最大最小值。然后 $N^2$ 枚举，左右端点，求和。算上查询的时间是 $\\log N$ 总时间复杂度为 $N^2\\log N$ 可以过 60 分。\n\n再说正解：\n\n题目大意可以简化为求下面这个式子的值：\n$$\n\\sum_{r=1}^{n}\\sum_{l=1}^{r}max(a[x]-a[y],l\\le x,y\\le r)\n$$\n观察上面的式子，其实可以从 $1\\rightarrow n$ 算出每个数对答案的影响，相加就是答案。\n\n那么怎么算贡献呢。用单调栈维护，一个点被弹出后就将其贡献减去，被压入后，就将其贡献加上。\n\n求作为最大值的贡献和求作为最小值的贡献其实差不多，求最小值时将数组变成负数就又变成了求最大值的问题。\n\n所以可以用一个函数解决。\n\n\n\n##### 代码\n\n---\n\n60 分\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1e5+3, inf = 2147483647;\ntypedef long long LL;\nLL T, n, a[maxn];\nstruct Tree {\n\tLL l, r, mx, mn;\n}tree[400003], tmp;\nLL ans_mn = inf, ans_mx;\nstruct P60 {\n\tinline void init() {\n\t\ttmp.l = tmp.r = tmp.mx = 0;\n\t\ttmp.mn = inf;\n\t\tfill(tree+1, tree+400001, tmp);\n\t}\n\tinline void build(int k, int ll, int rr) {\n\t\ttree[k].l = ll, tree[k].r = rr;\n\t\tif(ll == rr) {\n\t\t\tscanf(\"%d\", &tree[k].mn);\n\t\t\ttree[k].mx = tree[k].mn;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (ll + rr) >> 1;\n\t\tbuild(k << 1, ll, mid);\n\t\tbuild((k << 1)+1, mid+1, rr);\n\t\ttree[k].mx = max(tree[k<<1].mx, tree[(k<<1)+1].mx);\n\t\ttree[k].mn = min(tree[k<<1].mn, tree[(k<<1)+1].mn);\n\t}\n\tinline void check(int k, int ll, int rr) {\n\t\tif(tree[k].l >= ll && tree[k].r <= rr) {\n\t\t\tans_mn = min(ans_mn, tree[k].mn);\n\t\t\tans_mx = max(ans_mx, tree[k].mx);\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (tree[k].l + tree[k].r) >> 1;\n\t\tif(mid >= ll) check(k << 1, ll, rr);\n\t\tif(mid < rr) check((k<<1)+1, ll, rr);\n\t}\n\tinline LL solve() {\n\t\tinit();\n\t\tbuild(1, 1, n);\n\t\tLL Ans = 0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tfor(int j=i; j<=n; j++) {\n\t\t\t\tans_mx = 0, ans_mn = inf;\n\t\t\t\tcheck(1, i, j);\n\t\t\t\tAns += ans_mx - ans_mn;\n\t\t\t}\n\t\t}\n\t\treturn Ans;\n\t}\n}p60;\nint main() {\n\tfreopen(\"count.in\", \"r\", stdin);\n\tfreopen(\"count.out\", \"w\", stdout);\n\tcin>>T;\n\twhile (T--) {\n\t\tcin>>n\n\t\tcout<<p60.solve()<<endl;\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n\n---\n\n100 分\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1e5+3;\ntypedef long long LL;\nLL s[maxn], n, a[maxn], T;\nstruct P100 {\n\tinline LL solve() {\n\t\tLL h = 1, t = 0, sum = 0, ans = 0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\twhile (h <= t && a[i] > a[s[t]]) sum -= a[s[t]] * (s[t]-s[t-1]), t--;\n\t\t\ts[++t] = i;\n\t\t\tsum += a[i] * (i-s[t-1]);\n\t\t\tans += sum;\n\t\t}\n\t\treturn ans;\n\t}\n}p100;\nint main() {\n\tfreopen(\"count.in\", \"r\", stdin);\n\tfreopen(\"count.out\", \"w\", stdout);\n\tcin>>T;\n\twhile (T--) {\n\t\tcin>>n;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin>>a[i];\n\t\tLL ans = p100.solve();\n\t\tfor(int i=1; i<=n; i++) a[i] = -a[i];\n\t\tcout<<ans + p100.solve()<<endl;\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n","source":"_posts/2018-9-21校内测试.md","raw":"---\ntitle: 2018.9.21校内测试\ndate: 2018-09-21 21:36:42\ntags: 校内测试\nmathjax: true\n---\n\n{% pdf ./pro.pdf %}\n\n### 解题报告---9.21\n\n---\n\n\n\n#### $\\text{T1}$ 相遇\n\n---\n\n\n\n##### 反思\n\n---\n\nT1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。\n\n\n\n##### 解题思路\n\n---\n\n画几个图会发现 $a\\rightarrow b,c\\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\\text{LCA}$ 在另两个点之间的路径上。\n\n而一个点 $x$ 在一条路径 $s\\rightarrow t$ 上的充要条件是如下：\n\n- $depth[\\text{LCA}(s,t)]\\le depth[x]$\n- $\\text{LCA}(x,s)=x \\ ||\\  \\text{LCA}(x,t)=x$\n\n然后我们就可以做 $\\text{LCA}$ 进行求解，一组数据最多询问 $4$ 次。\n\n\n\n##### 代码\n\n---\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nconst int maxn = 2e5+3;\nint n, head[maxn], cnt, depth[maxn], T, fa[maxn][32], m;\nstruct edge {\n\tint to, nxt;\n}ed[maxn], tmp;\nstruct P100 {\n\tinline void reset() {\n\t\tcnt = 0;\n\t\ttmp.to = tmp.nxt = 0;\n\t\tfill(ed+1, ed+1+maxn-3, tmp);\n\t\tmemset(head, 0, sizeof(head));\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(fa, 0, sizeof(fa));\n\t}\n\tinline void addedge(int x, int y) {\n\t\ted[++cnt].nxt = head[x], head[x] = cnt, ed[cnt].to = y;\n\t\ted[++cnt].nxt = head[y], head[y] = cnt, ed[cnt].to = x;\n\t}\n\tinline void init() {\n\t\tfor(int j=1; 1<<j<=n; j++)\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tfa[i][j] = fa[fa[i][j-1]][j-1];\n\t}\n\tinline void dfs(int u) {\n\t\tfor(int i=head[u]; i; i=ed[i].nxt) {\n\t\t\tif(ed[i].to == fa[u][0]) continue;\n\t\t\tfa[ed[i].to][0] = u;\n\t\t\tdepth[ed[i].to] = depth[u] + 1;\n\t\t\tdfs(ed[i].to);\n\t\t}\n\t}\n\tinline int lca(int a, int b) {\n\t\tif(depth[a] > depth[b]) swap(a, b);\n\t\tint h = depth[b] - depth[a];\n\t\tfor(int i=0; 1<<i<=h; i++)\n\t\t\tif((1<<i)&h) b = fa[b][i];\n\t\tif(a != b) {\n\t\t\tfor(int i=(int)log2(n); i>=0; i--) {\n\t\t\t\tif(fa[a][i] != fa[b][i])\n\t\t\t\t\ta = fa[a][i], b = fa[b][i];\n\t\t\t}\n\t\t\ta = fa[a][0];\n\t\t}\n\t\treturn a;\n\t}\n\tinline void solve() {\n\t\tdfs(1);\n\t\tinit();\n\t}\n\tinline bool judge(int a, int b, int c, int d) {\n\t\tint x = lca(a, b), y = lca(c, d);\n\t\tif(depth[x] < depth[y]) swap(x, y), swap(a, c), swap(b, d);\n\t\tif(lca(x, c) == x || lca(x, d) == x) return true;\n\t\treturn false;\n\t}\n}p100;\nint main() {\n\tfreopen(\"railway.in\", \"r\", stdin);\n\tfreopen(\"railway.out\", \"w\", stdout);\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tp100.reset();\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tint x, y;\n\t\tfor(int i=1; i<n; i++) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp100.addedge(x, y);\n\t\t}\n\t\tp100.solve();\n\t\tint a, b, c, d;\n\t\tfor(int i=1; i<=m; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\tif(p100.judge(a, b, c, d)) printf(\"YES\\n\");\n\t\t\telse printf(\"NO\\n\");\n\t\t}\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n\n\n\n\n\n#### $\\text{T2}$ 计数\n\n---\n\n\n\n##### 反思\n\n---\n\n不开 `long long` 见祖宗，写了个 $60$ 分的暴力，因为没开 `long long` 所以 WA 成了 30 分，以后做题先看好数据范围，可以为了以防万一，能开 `long long` 就开 `long long` 。\n\n\n\n##### 解题思路\n\n---\n\n在考场上写了个线段树维护区间最大最小值。然后 $N^2$ 枚举，左右端点，求和。算上查询的时间是 $\\log N$ 总时间复杂度为 $N^2\\log N$ 可以过 60 分。\n\n再说正解：\n\n题目大意可以简化为求下面这个式子的值：\n$$\n\\sum_{r=1}^{n}\\sum_{l=1}^{r}max(a[x]-a[y],l\\le x,y\\le r)\n$$\n观察上面的式子，其实可以从 $1\\rightarrow n$ 算出每个数对答案的影响，相加就是答案。\n\n那么怎么算贡献呢。用单调栈维护，一个点被弹出后就将其贡献减去，被压入后，就将其贡献加上。\n\n求作为最大值的贡献和求作为最小值的贡献其实差不多，求最小值时将数组变成负数就又变成了求最大值的问题。\n\n所以可以用一个函数解决。\n\n\n\n##### 代码\n\n---\n\n60 分\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1e5+3, inf = 2147483647;\ntypedef long long LL;\nLL T, n, a[maxn];\nstruct Tree {\n\tLL l, r, mx, mn;\n}tree[400003], tmp;\nLL ans_mn = inf, ans_mx;\nstruct P60 {\n\tinline void init() {\n\t\ttmp.l = tmp.r = tmp.mx = 0;\n\t\ttmp.mn = inf;\n\t\tfill(tree+1, tree+400001, tmp);\n\t}\n\tinline void build(int k, int ll, int rr) {\n\t\ttree[k].l = ll, tree[k].r = rr;\n\t\tif(ll == rr) {\n\t\t\tscanf(\"%d\", &tree[k].mn);\n\t\t\ttree[k].mx = tree[k].mn;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (ll + rr) >> 1;\n\t\tbuild(k << 1, ll, mid);\n\t\tbuild((k << 1)+1, mid+1, rr);\n\t\ttree[k].mx = max(tree[k<<1].mx, tree[(k<<1)+1].mx);\n\t\ttree[k].mn = min(tree[k<<1].mn, tree[(k<<1)+1].mn);\n\t}\n\tinline void check(int k, int ll, int rr) {\n\t\tif(tree[k].l >= ll && tree[k].r <= rr) {\n\t\t\tans_mn = min(ans_mn, tree[k].mn);\n\t\t\tans_mx = max(ans_mx, tree[k].mx);\n\t\t\treturn ;\n\t\t}\n\t\tint mid = (tree[k].l + tree[k].r) >> 1;\n\t\tif(mid >= ll) check(k << 1, ll, rr);\n\t\tif(mid < rr) check((k<<1)+1, ll, rr);\n\t}\n\tinline LL solve() {\n\t\tinit();\n\t\tbuild(1, 1, n);\n\t\tLL Ans = 0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tfor(int j=i; j<=n; j++) {\n\t\t\t\tans_mx = 0, ans_mn = inf;\n\t\t\t\tcheck(1, i, j);\n\t\t\t\tAns += ans_mx - ans_mn;\n\t\t\t}\n\t\t}\n\t\treturn Ans;\n\t}\n}p60;\nint main() {\n\tfreopen(\"count.in\", \"r\", stdin);\n\tfreopen(\"count.out\", \"w\", stdout);\n\tcin>>T;\n\twhile (T--) {\n\t\tcin>>n\n\t\tcout<<p60.solve()<<endl;\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n\n---\n\n100 分\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1e5+3;\ntypedef long long LL;\nLL s[maxn], n, a[maxn], T;\nstruct P100 {\n\tinline LL solve() {\n\t\tLL h = 1, t = 0, sum = 0, ans = 0;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\twhile (h <= t && a[i] > a[s[t]]) sum -= a[s[t]] * (s[t]-s[t-1]), t--;\n\t\t\ts[++t] = i;\n\t\t\tsum += a[i] * (i-s[t-1]);\n\t\t\tans += sum;\n\t\t}\n\t\treturn ans;\n\t}\n}p100;\nint main() {\n\tfreopen(\"count.in\", \"r\", stdin);\n\tfreopen(\"count.out\", \"w\", stdout);\n\tcin>>T;\n\twhile (T--) {\n\t\tcin>>n;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tcin>>a[i];\n\t\tLL ans = p100.solve();\n\t\tfor(int i=1; i<=n; i++) a[i] = -a[i];\n\t\tcout<<ans + p100.solve()<<endl;\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n","slug":"2018-9-21校内测试","published":1,"updated":"2018-09-21T13:47:37.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmcms7j00000ns10uj1pf192","content":"\n\n\t<div class=\"row\">\n    <embed src=\"./pro.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h3 id=\"解题报告—9-21\"><a href=\"#解题报告—9-21\" class=\"headerlink\" title=\"解题报告—9.21\"></a>解题报告—9.21</h3><hr>\n<h4 id=\"text-T1-相遇\"><a href=\"#text-T1-相遇\" class=\"headerlink\" title=\"$\\text{T1}$ 相遇\"></a>$\\text{T1}$ 相遇</h4><hr>\n<h5 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h5><hr>\n<p>T1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。</p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><hr>\n<p>画几个图会发现 $a\\rightarrow b,c\\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\\text{LCA}$ 在另两个点之间的路径上。</p>\n<p>而一个点 $x$ 在一条路径 $s\\rightarrow t$ 上的充要条件是如下：</p>\n<ul>\n<li>$depth[\\text{LCA}(s,t)]\\le depth[x]$</li>\n<li>$\\text{LCA}(x,s)=x \\ ||\\  \\text{LCA}(x,t)=x$</li>\n</ul>\n<p>然后我们就可以做 $\\text{LCA}$ 进行求解，一组数据最多询问 $4$ 次。</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span>+<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, head[maxn], cnt, depth[maxn], T, fa[maxn][<span class=\"number\">32</span>], m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt;</span><br><span class=\"line\">&#125;ed[maxn], tmp;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P100</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp.to = tmp.nxt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tfill(ed+<span class=\"number\">1</span>, ed+<span class=\"number\">1</span>+maxn<span class=\"number\">-3</span>, tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(head));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(depth, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(depth));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(fa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(fa));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t\ted[++cnt].nxt = head[x], head[x] = cnt, ed[cnt].to = y;</span><br><span class=\"line\">\t\ted[++cnt].nxt = head[y], head[y] = cnt, ed[cnt].to = x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; <span class=\"number\">1</span>&lt;&lt;j&lt;=n; j++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)</span><br><span class=\"line\">\t\t\t\tfa[i][j] = fa[fa[i][j<span class=\"number\">-1</span>]][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[u]; i; i=ed[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ed[i].to == fa[u][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tfa[ed[i].to][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">\t\t\tdepth[ed[i].to] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tdfs(ed[i].to);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(depth[a] &gt; depth[b]) swap(a, b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> h = depth[b] - depth[a];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; <span class=\"number\">1</span>&lt;&lt;i&lt;=h; i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"number\">1</span>&lt;&lt;i)&amp;h) b = fa[b][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != b) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=(<span class=\"keyword\">int</span>)log2(n); i&gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(fa[a][i] != fa[b][i])</span><br><span class=\"line\">\t\t\t\t\ta = fa[a][i], b = fa[b][i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ta = fa[a][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tdfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = lca(a, b), y = lca(c, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(depth[x] &lt; depth[y]) swap(x, y), swap(a, c), swap(b, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lca(x, c) == x || lca(x, d) == x) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p100;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"railway.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"railway.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\tp100.reset();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\tp100.addedge(x, y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp100.solve();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b, c, d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p100.judge(a, b, c, d)) <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"text-T2-计数\"><a href=\"#text-T2-计数\" class=\"headerlink\" title=\"$\\text{T2}$ 计数\"></a>$\\text{T2}$ 计数</h4><hr>\n<h5 id=\"反思-1\"><a href=\"#反思-1\" class=\"headerlink\" title=\"反思\"></a>反思</h5><hr>\n<p>不开 <code>long long</code> 见祖宗，写了个 $60$ 分的暴力，因为没开 <code>long long</code> 所以 WA 成了 30 分，以后做题先看好数据范围，可以为了以防万一，能开 <code>long long</code> 就开 <code>long long</code> 。</p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><hr>\n<p>在考场上写了个线段树维护区间最大最小值。然后 $N^2$ 枚举，左右端点，求和。算上查询的时间是 $\\log N$ 总时间复杂度为 $N^2\\log N$ 可以过 60 分。</p>\n<p>再说正解：</p>\n<p>题目大意可以简化为求下面这个式子的值：<br>$$<br>\\sum_{r=1}^{n}\\sum_{l=1}^{r}max(a[x]-a[y],l\\le x,y\\le r)<br>$$<br>观察上面的式子，其实可以从 $1\\rightarrow n$ 算出每个数对答案的影响，相加就是答案。</p>\n<p>那么怎么算贡献呢。用单调栈维护，一个点被弹出后就将其贡献减去，被压入后，就将其贡献加上。</p>\n<p>求作为最大值的贡献和求作为最小值的贡献其实差不多，求最小值时将数组变成负数就又变成了求最大值的问题。</p>\n<p>所以可以用一个函数解决。</p>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><hr>\n<p>60 分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span>+<span class=\"number\">3</span>, inf = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\">LL T, n, a[maxn];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span> &#123;</span></span><br><span class=\"line\">\tLL l, r, mx, mn;</span><br><span class=\"line\">&#125;tree[<span class=\"number\">400003</span>], tmp;</span><br><span class=\"line\">LL ans_mn = inf, ans_mx;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P60</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\ttmp.l = tmp.r = tmp.mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp.mn = inf;</span><br><span class=\"line\">\t\tfill(tree+<span class=\"number\">1</span>, tree+<span class=\"number\">400001</span>, tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> ll, <span class=\"keyword\">int</span> rr)</span> </span>&#123;</span><br><span class=\"line\">\t\ttree[k].l = ll, tree[k].r = rr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ll == rr) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tree[k].mn);</span><br><span class=\"line\">\t\t\ttree[k].mx = tree[k].mn;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (ll + rr) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tbuild(k &lt;&lt; <span class=\"number\">1</span>, ll, mid);</span><br><span class=\"line\">\t\tbuild((k &lt;&lt; <span class=\"number\">1</span>)+<span class=\"number\">1</span>, mid+<span class=\"number\">1</span>, rr);</span><br><span class=\"line\">\t\ttree[k].mx = max(tree[k&lt;&lt;<span class=\"number\">1</span>].mx, tree[(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>].mx);</span><br><span class=\"line\">\t\ttree[k].mn = min(tree[k&lt;&lt;<span class=\"number\">1</span>].mn, tree[(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>].mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> ll, <span class=\"keyword\">int</span> rr)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(tree[k].l &gt;= ll &amp;&amp; tree[k].r &lt;= rr) &#123;</span><br><span class=\"line\">\t\t\tans_mn = min(ans_mn, tree[k].mn);</span><br><span class=\"line\">\t\t\tans_mx = max(ans_mx, tree[k].mx);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mid &gt;= ll) check(k &lt;&lt; <span class=\"number\">1</span>, ll, rr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mid &lt; rr) check((k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>, ll, rr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t\tbuild(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t\tLL Ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i; j&lt;=n; j++) &#123;</span><br><span class=\"line\">\t\t\t\tans_mx = <span class=\"number\">0</span>, ans_mn = inf;</span><br><span class=\"line\">\t\t\t\tcheck(<span class=\"number\">1</span>, i, j);</span><br><span class=\"line\">\t\t\t\tAns += ans_mx - ans_mn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p60;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;n</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;p60.solve()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>100 分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span>+<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\">LL s[maxn], n, a[maxn], T;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P100</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tLL h = <span class=\"number\">1</span>, t = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[s[t]]) sum -= a[s[t]] * (s[t]-s[t<span class=\"number\">-1</span>]), t--;</span><br><span class=\"line\">\t\t\ts[++t] = i;</span><br><span class=\"line\">\t\t\tsum += a[i] * (i-s[t<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\tans += sum;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p100;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;a[i];</span><br><span class=\"line\">\t\tLL ans = p100.solve();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) a[i] = -a[i];</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ans + p100.solve()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"解题报告—9.21\n\n\n\n$\\text{T1}$ 相遇\n\n\n\n反思\n\n\n\nT1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。\n\n解题思路\n\n\n\n画几个图会发现 $a\\rightarrow b,c\\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\\text{LCA}$ 在另两个点之间的路径上。\n\n而一个点 $x$ 在一条路径 $s\\rightarrow t$ 上的","more":"\n\n\t<div class=\"row\">\n    <embed src=\"./pro.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h3 id=\"解题报告—9-21\"><a href=\"#解题报告—9-21\" class=\"headerlink\" title=\"解题报告—9.21\"></a>解题报告—9.21</h3><hr>\n<h4 id=\"text-T1-相遇\"><a href=\"#text-T1-相遇\" class=\"headerlink\" title=\"$\\text{T1}$ 相遇\"></a>$\\text{T1}$ 相遇</h4><hr>\n<h5 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h5><hr>\n<p>T1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。</p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><hr>\n<p>画几个图会发现 $a\\rightarrow b,c\\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\\text{LCA}$ 在另两个点之间的路径上。</p>\n<p>而一个点 $x$ 在一条路径 $s\\rightarrow t$ 上的充要条件是如下：</p>\n<ul>\n<li>$depth[\\text{LCA}(s,t)]\\le depth[x]$</li>\n<li>$\\text{LCA}(x,s)=x \\ ||\\  \\text{LCA}(x,t)=x$</li>\n</ul>\n<p>然后我们就可以做 $\\text{LCA}$ 进行求解，一组数据最多询问 $4$ 次。</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><hr>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">2e5</span>+<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n, head[maxn], cnt, depth[maxn], T, fa[maxn][<span class=\"number\">32</span>], m;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">edge</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> to, nxt;</span><br><span class=\"line\">&#125;ed[maxn], tmp;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P100</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp.to = tmp.nxt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tfill(ed+<span class=\"number\">1</span>, ed+<span class=\"number\">1</span>+maxn<span class=\"number\">-3</span>, tmp);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(head));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(depth, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(depth));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(fa, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(fa));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t\ted[++cnt].nxt = head[x], head[x] = cnt, ed[cnt].to = y;</span><br><span class=\"line\">\t\ted[++cnt].nxt = head[y], head[y] = cnt, ed[cnt].to = x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; <span class=\"number\">1</span>&lt;&lt;j&lt;=n; j++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)</span><br><span class=\"line\">\t\t\t\tfa[i][j] = fa[fa[i][j<span class=\"number\">-1</span>]][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=head[u]; i; i=ed[i].nxt) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ed[i].to == fa[u][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tfa[ed[i].to][<span class=\"number\">0</span>] = u;</span><br><span class=\"line\">\t\t\tdepth[ed[i].to] = depth[u] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tdfs(ed[i].to);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(depth[a] &gt; depth[b]) swap(a, b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> h = depth[b] - depth[a];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; <span class=\"number\">1</span>&lt;&lt;i&lt;=h; i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>((<span class=\"number\">1</span>&lt;&lt;i)&amp;h) b = fa[b][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a != b) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=(<span class=\"keyword\">int</span>)log2(n); i&gt;=<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(fa[a][i] != fa[b][i])</span><br><span class=\"line\">\t\t\t\t\ta = fa[a][i], b = fa[b][i];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ta = fa[a][<span class=\"number\">0</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tdfs(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x = lca(a, b), y = lca(c, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(depth[x] &lt; depth[y]) swap(x, y), swap(a, c), swap(b, d);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lca(x, c) == x || lca(x, d) == x) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p100;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"railway.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"railway.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;T);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\tp100.reset();</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x, y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>, &amp;x, &amp;y);</span><br><span class=\"line\">\t\t\tp100.addedge(x, y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp100.solve();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a, b, c, d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d%d%d\"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p100.judge(a, b, c, d)) <span class=\"built_in\">printf</span>(<span class=\"string\">\"YES\\n\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"NO\\n\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"text-T2-计数\"><a href=\"#text-T2-计数\" class=\"headerlink\" title=\"$\\text{T2}$ 计数\"></a>$\\text{T2}$ 计数</h4><hr>\n<h5 id=\"反思-1\"><a href=\"#反思-1\" class=\"headerlink\" title=\"反思\"></a>反思</h5><hr>\n<p>不开 <code>long long</code> 见祖宗，写了个 $60$ 分的暴力，因为没开 <code>long long</code> 所以 WA 成了 30 分，以后做题先看好数据范围，可以为了以防万一，能开 <code>long long</code> 就开 <code>long long</code> 。</p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><hr>\n<p>在考场上写了个线段树维护区间最大最小值。然后 $N^2$ 枚举，左右端点，求和。算上查询的时间是 $\\log N$ 总时间复杂度为 $N^2\\log N$ 可以过 60 分。</p>\n<p>再说正解：</p>\n<p>题目大意可以简化为求下面这个式子的值：<br>$$<br>\\sum_{r=1}^{n}\\sum_{l=1}^{r}max(a[x]-a[y],l\\le x,y\\le r)<br>$$<br>观察上面的式子，其实可以从 $1\\rightarrow n$ 算出每个数对答案的影响，相加就是答案。</p>\n<p>那么怎么算贡献呢。用单调栈维护，一个点被弹出后就将其贡献减去，被压入后，就将其贡献加上。</p>\n<p>求作为最大值的贡献和求作为最小值的贡献其实差不多，求最小值时将数组变成负数就又变成了求最大值的问题。</p>\n<p>所以可以用一个函数解决。</p>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><hr>\n<p>60 分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span>+<span class=\"number\">3</span>, inf = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\">LL T, n, a[maxn];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Tree</span> &#123;</span></span><br><span class=\"line\">\tLL l, r, mx, mn;</span><br><span class=\"line\">&#125;tree[<span class=\"number\">400003</span>], tmp;</span><br><span class=\"line\">LL ans_mn = inf, ans_mx;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P60</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\ttmp.l = tmp.r = tmp.mx = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\ttmp.mn = inf;</span><br><span class=\"line\">\t\tfill(tree+<span class=\"number\">1</span>, tree+<span class=\"number\">400001</span>, tmp);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> ll, <span class=\"keyword\">int</span> rr)</span> </span>&#123;</span><br><span class=\"line\">\t\ttree[k].l = ll, tree[k].r = rr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ll == rr) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>, &amp;tree[k].mn);</span><br><span class=\"line\">\t\t\ttree[k].mx = tree[k].mn;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (ll + rr) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tbuild(k &lt;&lt; <span class=\"number\">1</span>, ll, mid);</span><br><span class=\"line\">\t\tbuild((k &lt;&lt; <span class=\"number\">1</span>)+<span class=\"number\">1</span>, mid+<span class=\"number\">1</span>, rr);</span><br><span class=\"line\">\t\ttree[k].mx = max(tree[k&lt;&lt;<span class=\"number\">1</span>].mx, tree[(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>].mx);</span><br><span class=\"line\">\t\ttree[k].mn = min(tree[k&lt;&lt;<span class=\"number\">1</span>].mn, tree[(k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>].mn);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> ll, <span class=\"keyword\">int</span> rr)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(tree[k].l &gt;= ll &amp;&amp; tree[k].r &lt;= rr) &#123;</span><br><span class=\"line\">\t\t\tans_mn = min(ans_mn, tree[k].mn);</span><br><span class=\"line\">\t\t\tans_mx = max(ans_mx, tree[k].mx);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mid &gt;= ll) check(k &lt;&lt; <span class=\"number\">1</span>, ll, rr);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mid &lt; rr) check((k&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>, ll, rr);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tinit();</span><br><span class=\"line\">\t\tbuild(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">\t\tLL Ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i; j&lt;=n; j++) &#123;</span><br><span class=\"line\">\t\t\t\tans_mx = <span class=\"number\">0</span>, ans_mn = inf;</span><br><span class=\"line\">\t\t\t\tcheck(<span class=\"number\">1</span>, i, j);</span><br><span class=\"line\">\t\t\t\tAns += ans_mx - ans_mn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p60;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;n</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;p60.solve()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>100 分</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxn = <span class=\"number\">1e5</span>+<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\">LL s[maxn], n, a[maxn], T;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">P100</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tLL h = <span class=\"number\">1</span>, t = <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[s[t]]) sum -= a[s[t]] * (s[t]-s[t<span class=\"number\">-1</span>]), t--;</span><br><span class=\"line\">\t\t\ts[++t] = i;</span><br><span class=\"line\">\t\t\tsum += a[i] * (i-s[t<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\tans += sum;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;p100;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.in\"</span>, <span class=\"string\">\"r\"</span>, <span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfreopen(<span class=\"string\">\"count.out\"</span>, <span class=\"string\">\"w\"</span>, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;T;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span>&gt;&gt;a[i];</span><br><span class=\"line\">\t\tLL ans = p100.solve();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) a[i] = -a[i];</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;ans + p100.solve()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\tfclose(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-09-20T07:27:19.543Z","updated":"2018-09-19T23:38:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmcms7j90002ns10kwzkoftf","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuick Start\nCreate a new post\n1\n\n\n$ hexo new \"My New Post\"\n\n\nMore info: Writing\n\nRun server\n1\n\n\n$ hexo s","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"MD 解析器性能测试 + 查锅","date":"2018-09-21T14:25:06.000Z","mathjax":true,"_content":"**后缀自动机**是一个能解决许多字符串相关问题的有力的数据结构。\n\n举个例子，字符串问题：\n\n- 在另一个字符串中搜索一个字符串的所有出现位置。\n- 计算给定的字符串中有多少个不同的子串。\n\n以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。\n\n直观上，字符串的后缀自动机可以理解为给定字符串的**所有子串**的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造后缀自动机的时间复杂度仅为 $O(n)$（这里我们将字符集的大小 $k$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\\log k)$）。\n\n## 后缀自动机的定义\n\n给定字符串 $s$ 的后缀自动机是一个接受所有字符串 $s$ 的后缀的最小 **DFA**（确定性有限自动机或确定性有限状态自动机）。\n\n换句话说：\n\n- 后缀自动机是一张有向无环图。顶点被称作**状态**，边被称作状态间的**转移**。\n- 一个状态 $t_0$ 为**初始状态**，它必定为这张图的源点（其它各点均与 $t_0$ 联通）。\n- 每个**转移**都标有一些字母。从一个顶点出发的所有转移均**不同**。\n- 一个或多个状态为**终止状态**。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到一个终止状态的路径构成。\n- 后缀自动机是所有满足上述条件的自动机中顶点数最少的一个。\n\n### 子串的性质\n\n后缀自动机最简单和最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个**子串**。反之每个 $s$ 的子串对应于从 $t_0$ 开始的某条路径。\n\n为了简化表达，我们将会说子串**对应于**一条路径（从 $t_0$ 开始且一些标号构成这个子串）。反过来我们说任意一条路径**对应于**它的标号构成的字符串。\n\n一条或多条路径可以到达一个状态，因此我们说一个状态对应于字符串的集合，这也对应于那些路径。\n\n### 构造后缀自动机的实例\n\n我们将会在这里展示一些简单的字符串的后缀自动机。\n\n我们用蓝色表示初始状态，用绿色表示终止状态。\n\n对于字符串 $s=``\"$：\n\n![](./SA.pdf.svg)\n\n对于字符串 $s=``a\\!\"$：\n\n![](./SAa.pdf.svg)\n\n对于字符串 $s=``aa\\!\"$：\n\n![](./SAaa.pdf.svg)\n\n对于字符串 $s=``ab\\!\"$：\n\n![](./SAab.pdf.svg)\n\n对于字符串 $s=``abb\\!\"$：\n\n![](./SAabb.pdf.svg)\n\n对于字符串 $s=``abbb\\!\"$：\n\n![](./SAabbb.pdf.svg)\n\n## 在线性时间内构造后缀自动机\n\n在我们描述线性时间内构造后缀自动机的算法之前，我们需要引入几个对理解构造过程非常重要的新概念并简单证明。\n\n### 结束位置 <script type=\"math/tex\">endpos</script>\n\n<p>考虑字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 的任意非空子串 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> ，我们记 <span><span class=\"MathJax_Preview\">endpos(t)</span><script type=\"math/tex\">endpos(t)</script></span> 为在字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 中 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 <span><span class=\"MathJax_Preview\">``abcbc\\!\"</span><script type=\"math/tex\">``abcbc\\!\"</script></span>，我们有 <span><span class=\"MathJax_Preview\">endpos(``bc\\!\")=2,\\,4</span><script type=\"math/tex\">endpos(``bc\\!\")=2,\\,4</script></span>。</p>\n\n当两个子串 $t_1$ 与 $t_2$ 的末尾集合相等时我们称它们是 $endpos$ 等价的：即 $endpos(t_1)=endpos(t_2)$。这样所有字符串 $s$ 的非空子串都可以根据它们的 **$endpos$** 集合被分为几个**等价类**。\n\n显然，在后缀自动机中的每个状态对应于一个或多个 $endpos$ 相同的子串。换句话说，后缀自动机中的状态数等于所有子串的等价类的个数，加上初始状态。后缀自动机的状态个数等价于 $endpos$ 相同的一个或多个子串。\n\n我们稍后将会用这个假设介绍构造后缀自动机的算法。在那时我们将会发现，后缀自动机需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（这篇文章不会证明后缀自动机的最小性）。\n\n由 $endpos$ 的值我们可以得到一些重要结论：\n\n> **引理 1：**当且仅当字符串 $u$ 以 $w$ 的一个后缀的形式出现在字符串 $s$ 中时，两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）是 $endpos$ 等价的。\n\n引理显然成立。如果 $u$ 和 $v$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 值相等。\n\n> **引理 2：**考虑两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）。则它们的 $endpos$ 构成的集合要么完全没有交集，要么 $endpos(w)$ 是 $endpos(u)$ 的一个子集。并且这依赖于 $u$ 是否为 $w$ 的一个后缀。即：\n>\n> $$\n> \\begin{cases}\n>  endpos(w)\\subseteq endpos(u)&\\text{若 $u$ 为 $w$ 的一个后缀}\\\\\n>  endpos(w)\\cap endpos(u)=\\emptyset&\\text{另一种情况}\\\\\n> \\end{cases}\n> $$\n\n证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 都在一个位置结束，即 $u$ 是 $w$ 的一个后缀。但是如果如此在每次 $w$ 出现的位置子串 $u$ 也会出现，这意味着 $endpos(w)$ 是 $endpos(u)$ 的一个子集。\n\n> **引理 3：**考虑一个 $endpos$ 等价类。将类中的所有子串按长度非递增的顺序排序。即每个子串都会比它前一个子串短，与此同时每个子串也是它前一个子串的一个后缀。换句话说，同一等价类中的所有子串均互为后缀，且子串的长度恰好覆盖整个区间 $[x,\\,y]$。\n\n证明：固定一些 $endpos$ 等价类。如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。\n\n由引理 1，两个不同的 $endpos$ 等价字符串中较短的一个总是较长的一个的真后缀。因此，等价类中不可能有两个等长的字符串。\n\n记 $w$ 为等价类中最长的字符串，类似地，记 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[length(u),\\,length(w)]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中。因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀与字符串 $w$ $endpos$ 等价。\n\n### 后缀链接 <script type=\"math/tex\">link</script>\n\n考虑后缀自动机中满足 $v\\ne t_0$ 的一些状态。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。\n\n我们还知道字符串 $w$ 的前几个后缀（如果我们用长度降序考虑这些后缀）在这个等价类中全部被包含，且所有其它后缀（至少一个—空后缀）在其它的等价类中。我们记 $t$ 为最大的这样的后缀，然后用后缀链接连到 $t$ 上。\n\n换句话说，一个**后缀链接** $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。\n\n以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串），为了方便我们规定 $endpos(t)=\\{-1,\\,0,\\,\\ldots,\\,length(s)-1\\}$。\n\n> **引理 4：**所有后缀链接构成一棵根节点为 $t_0$ 的树。\n\n证明：考虑任意满足 $v\\ne t_0$ 的状态，一个后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（根据后缀链接的定义和引理 3）。因此，通过在后缀链接上移动，我们早晚会到达对应空串的初始状态 $t_0$。\n\n> **引理 5：**如果我们使用集合 $endpos$ 构造一棵树（所有子节点的集合为父节点的子集），则这个结构由后缀链接连接起来。\n\n证明：由引理 2，我们可以用 $endpos$ 集合构造一棵树（因为两个集合要么完全没有交集要么互为子集）。\n\n我们现在考虑任意满足 $v\\ne t_0$ 的状态和它的后缀链接 $link(v)$，由后缀链接和引理 2，我们可以得到\n\n$$\nendpos(v)\\subseteq endpos(link(v))\n$$\n\n，这与前面的引理证明了以下断言成立：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。\n\n以下是对于字符串 $``abcbc\\!\"$ 构造后缀自动机时产生的后缀链接树的一个**例子**，节点被标记为对应等价类中最长的子串。\n\n![](./SA_suffix_links.pdf.svg)\n\n### 小结\n\n在学习算法本身前，我们对之前学过的知识进行一下总结，并引入一些辅助记号。\n\n- $s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；\n- 后缀自动机由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；\n- 对于每一个状态 $v$，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$。那么所有对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),\\,len(v)]$ 中的每一个整数。\n- 对于任意满足 $v\\ne t_0$ 的状态，定义后缀链接为连接到对应字符串 $longest(v)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树，与此同时，这棵树形成了 $endpos$ 集合间的包含关系。\n- 我们可以对 $v\\ne t_0$ 的状态使用后缀链接 $link(v)$ 解释 $minlen(v)$ 如下：\n\n$$\nminlen(v)=len(link(v))+1.\n$$\n\n- 如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，早晚都会到达初始状态 $t_0$。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),\\,len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,\\,len(v_0)]$。\n\n### 算法\n\n现在我们可以学习算法本身了。这个算法是**在线**算法，这意味着我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护后缀自动机。\n\n为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的一个转移列表，我们不会标记终止状态（但是我们稍后会展示在构造后缀自动机后如何分配这些标记）。\n\n一开始后缀自动机只包含一个状态 $t_0$，编号为 $0$（其它状态的编号为 $1,\\,2,\\,\\ldots$）。为了方便，我们分配给它 $len=0$ 和 $link=-1$（$-1$ 表示一个虚拟的不存在的状态）。\n\n现在整个任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：\n\n- 令 $last$ 为对应添加字符 $c$ 之前的整个字符串（一开始我们设置 $last=0$ 且我们会在算法的最后一步对应地更新 $last$）。\n- 创建一个新的状态 $cur$，并将 $len(cur)$ 赋值为 $len(last)+1$，在这时 $link(cur)$ 的值还未知。\n- 现在我们按以下流程进行：我们从状态 $last$ 开始。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的后缀链接，我们就停下来，并将这个状态标记为 $p$。\n- 如果没有找到这样的状态 $p$，我们就到达了虚拟状态 $-1$，我们将 $link(cur)$ 赋值为 $-1$ 并退出。\n- 假设现在我们找到了一个状态 $p$，其可以转移到字符 $c$，我们将这个状态转移到的状态标记为 $q$。\n- 现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$，要么不是。\n- 如果 $len(p)+1=len(q)$，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。\n-   否则就会有些复杂。需要**复制**状态 $q$：我们创建一个新的状态 $clone$，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$。  \n    复制之后，我们将后缀链接从 $cur$ 指向 $clone$，也从 $q$ 指向 $clone$。  \n    最终我们需要使用后缀链接从状态 $p$ 返回，因为存在一条通过 $c$ 到状态 $q$ 的转移，并在此过程中重定向所有状态到状态 $clone$。\n- 以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$。\n\n如果我们还想知道哪些状态是**终止状态**而哪些不是，我们可以在为字符串 $s$ 构造完完整的后缀自动机后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会精确地标记字符串 $s$ 的所有后缀，这些状态恰好是终止状态。\n\n在下一部分，我们将观察算法每一步的细节，并证明它的**正确性**。\n\n现在，我们只注意到，因为我们只为 $s$ 的每个字符创建一个或两个新状态所以后缀自动机只包含**线性个**状态。\n\n转移个数是线性规模的，以及总体上算法的运行时间是线性规模的，这两点还不那么清\n楚。\n\n### 正确性证明\n\n- 若一个转移 $(p,\\,q)$ 满足 $len(p)+1=len(q)$ 则我们称这个转移是**连续的**。否则，即当 $len(p)+1<len(q)$ 时，这个转移被称为**不连续的**。  从算法描述中可以看出，连续的和非连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，非连续的转移可能会改变（转移边的端点可能会改变）。\n- 为了避免引起歧义，我们记向后缀自动机中插入当前字符 $c$ 之前的字符串为 $s$。\n- 算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。\n- 在创建一个新的状态之后，我们会从对应于整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个从字符 $c$ 到新状态 $cur$ 的转移。然而我我们只能添加与原来已存在的转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。\n- 最简单的情况是我们到达了虚拟状态 $-1$，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$。\n- 第二种情况下，我们找到了现有的转移 $(p,\\,q)$。这意味着我们尝试向自动机内添加一个**已经存在的**字符串 $x+c$（其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。  然而，有一个难点。从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$，即这个状态的 $len$ 应该是 $len(p)+1$。然而还不存在这样的状态，即 $len(q)>len(p)+1$。这种情况下，我们必须要通过拆开状态 $q$ 来创建一个这样的状态。\n- 如果转移 $(p,\\,q)$ 是连续的，那么 $len(q)=len(p)+1$。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$。\n-   否则转移是不连续的，即 $len(q)>len(p)+1$，这意味着状态 $q$ 不只对应于长度为$len(p)+1$ 的后缀 $s+c$，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。  \n    我们如何拆开一个状态呢？我们**复制**状态 $q$，产生一个状态 $clone$，我们将 $len(clone)$ 赋值为 $len(p)+1$。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$。  \n    在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$。  \n    最后一步我们将一些到 $q$ 转移重定向到 $clone$。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$（其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从顶点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。\n\n### 对操作次数为线性的证明\n\n首先我们假设字符集大小为**常数**。如果字符集大小不是常数，后缀自动机的时间复杂度就不是线性的。从一个顶点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $k$ 为字符集的大小，则算法的渐进时间复杂度为 $O(n\\log k)$，空间复杂度为 $O(n)$。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个顶点的转移存储为长度为 $k$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$，空间复杂度为 $O(nk)$。\n\n所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移—这些操作的时间复杂度都为 $O(1)$。\n\n如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：\n\n- 第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。\n- 第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。\n- 第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。\n\n我们使用后缀自动机的大小（状态数和转移数）为**线性的**的事实（对状态数是线性的的证明就是算法本身，对状态数为线性的的证明将在稍后实现算法后给出）。\n\n因此上述**第一处和第二处**的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。\n\n还需为**第三处**估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$。我们记 $v=longest(p)$，这是一个字符串 $s$ 的后缀，每次迭代长度都递减—因为作为字符串 $s$ 的位置随着每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$ $(k\\ge2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。\n\n因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。\n\n### 实现\n\n首先，我们描述一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将会用一个 `map` 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\\log k)$ 的时间复杂度内处理整个字符串。\n\n```cpp\nstruct state {\n    int len, link;\n    map<char, int> next;\n};\n```\n\n后缀自动机本身将会存储在一个 `state` 结构体数组中。我们记录当前自动机的大小 `sz` 和变量 `last`，当前整个字符串对应的状态。\n\n```cpp\nconst int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n```\n\n我们定义一个函数来初始化后缀自动机（创建一个只有一个状态的后缀自动机）。\n\n```cpp\nvoid sa_init() {\n    st[0].len = 0;\n    st[0].link = -1;\n    sz++;\n    last = 0;\n}\n```\n\n最终我们给出主函数的实现—给当前行末增加一个字符，对应地重建自动机。\n\n```cpp\nvoid sa_extend(char c) {\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p = last;\n    while (p != -1 && !st[p].next.count(c)) {\n        st[p].next[c] = cur;\n        p = st[p].link;\n    }\n    if (p == -1) {\n        st[cur].link = 0;\n    } else {\n        int q = st[p].next[c];\n        if (st[p].len + 1 = st[q].len) {\n            st[cur].link = q;\n        } else {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            while (p != -1 && st[p].next[c] == q) {\n                st[p].next[c] = clone;\n                p = st[p].link;\n            }\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n```\n\n正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(nk)$，其中 $k$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小 $k$ 任意的后缀自动机。但是这样你需要为每一个状态储存一个大小为 $k$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。\n\n## 更多的性质\n\n### 状态数\n\n对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的状态数**不会超过 $2n-1$** （假设 $n\\ge2$）。\n\n对上述结论的证明就是算法本身，因为一开始自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。\n\n然而我们也能在**不知道这个算法**的情况下**展示**这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。另外这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部顶点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部顶点的度数大于一的树，并且叶子节点的个数不超过 $n$。因此这样的树里有不超过 $2n-1$ 个节点。\n\n对于每个确定的 $n$，状态数的上界是确定的。一个可能的字符串是：\n\n$$\n``abbb\\ldots bbb\\!\"\n$$\n\n从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。\n\n### 转移数\n\n对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的转移数**不会超过 $3n-4$**（假设 $n\\ge 3$）。\n\n证明如下：\n\n我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的最长路径的生成树。生成树的骨架只包含连续的边，因此数量少于状态数，即，边数不会超过 $2n-2$。\n\n现在我们来估计非连续的转移的数量。令当前非连续转移为 $(p,\\,q)$，其字符为 $c$。我们取它的对应字符串 $u+c+w$，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径，$w$ 对应于从 $p$ 到任意终止状态的最长路径。一方面，对于每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$（因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$。\n\n将以上两个估计值结合起来，我们可以得到上界 $3n-3$。然而，最大的状态数只能在测试数据 $``abbb\\ldots bbb\\!\"$ 中产生，这个测试数据的转移数量显然少于 $3n-3$，我们可以获得更为紧确的后缀自动机的转移数的上界：$3n-4$。\n\n上界可以通过字符串\n\n$$\n``abbb\\ldots bbbc\\!\"\n$$\n\n达到。\n\n## 应用\n\n下面我们来看一下一些可以用后缀自动机解决的问题。为了简单，我们假设字符集的大小 $k$ 为常数，允许我们认为增加一个字符和遍历的复杂度为常数。\n\n### 检查字符串是否出现\n\n> 给一个文本串 $T$ 和多个模式串 $P$，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。\n\n我们在 $O(length(T))$ 的时间内为文本串 $T$ 构造后缀自动机。为了检查模式串 $T$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$，那么模式串在 $T$ 中出现过。因此\n\n对于每个字符串 $P$ 算法的时间复杂度为 $O(length(P))$。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。\n\n### 不同子串个数\n\n> 给一个字符串 $S$，计算不同子串的个数。\n\n为字符串 $S$ 构造后缀自动机。\n\n每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。\n\n考虑到后缀自动机为有向无环图，不同路径的条数可以使用动态规划计算。\n\n即，令 $d[v]$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程式：\n\n$$\nd[v]=1+\\sum_{w:(v,\\,w,\\,c)\\in SA}d[w]\n$$\n\n即，$d[v]$ 可以表示为所有 $v$ 的转移的末端的和。\n\n所以不同子串的个数为 $d[t_0]-1$（因为要去掉空子串）。\n\n总时间复杂度为：$O(length(S))$。\n\n### 所有不同子串的总长度\n\n> 给定一个字符串 $S$，计算所有不同子串的总长度。\n\n本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d[v]$ 和它们的总长度 $ans[v]$。\n\n我们已经在上一题中介绍了如何计算 $d[v]$。$ans[v]$ 的值可以使用通过以下递推式计算：\n\n$$\nans[v]=\\sum_{w:(v,\\,w,\\,c)\\in DAWG}d[w]+ans[w]\n$$\n\n我们取每个邻接顶点 $w$ 的答案，并加上 $d[w]$（因为从状态 $v$ 出发的子串都增加了一个字符）。\n\n算法的时间复杂度仍然是 $O(length(S))$。\n\n### 字典序第 <script type=\"math/tex\">k</script> 大子串\n\n> 给定一个字符串 $S$。多组询问，每组询问给定一个数 $K_i$，查询所有子串中词典序第 $k$ 大的子串。\n\n解决这个问题的思路基于前两个问题的思路。字典序第 $k$ 大的子串对应于后缀自动机中字典序第 $k$ 大的路径。因此在计算每个状态的路径数后，我们可以很容易地从后缀自动机的根开始找到第 $k$ 大的路径。\n\n预处理的时间复杂度为 $O(length(S))$，单次查询的复杂度为 $O(length(ans)\\cdot k)$（其中 $ans$ 是查询的答案，$k$ 为字符集的大小）。\n\n### 最小循环移位\n\n> 给定一个字符串 $S$。找出字典序最小的循环移位。\n\n我们为字符串 $S+S$ 构造后缀自动机。则后缀自动机本身将包含字符串 $S$ 的所有循环移位作为路径。\n\n所以问题简化为寻找最小的长度为 $length(S)$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。\n\n总的时间复杂度为 $O(length(S))$。\n\n### 出现次数\n\n> 对于一个给定的文本串 $T$，有多组询问，每组询问给一个模式串 $P$，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。\n\n我们为文本串 $T$ 构造后缀自动机。\n\n接下来我们做以下的预处理：对于自动机中的每个状态 $v$，预处理值等于 $endpos(v)$ 这个集合大小的 $cnt[v]$。事实上对应于同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。\n\n然而我们不能明确的构造集合 $endpos$，因此我们只考虑它们的大小 $cnt$。\n\n为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$），我们用 $cnt=1$ 初始化它。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt[v]$ 的值加到后缀链接上，即：\n\n$$\ncnt[link(v)]+=cnt[v]\n$$\n\n这样做每个状态的答案都是正确的。\n\n为什么这是正确的？通过复制获得的状态，恰好是 $length(T)$，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$，其它状态的 $cnt$ 值赋为 $0$。\n\n接下来我们对每一个 $v$ 执行以下操作：$cnt[link(v)]+=cnt[v]$。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt[v]$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt[v]$ 次。\n\n为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到**一个**其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。\n\n因此，我们可以在 $O(length(T))$ 的时间内计算出所有状态的 $cnt$ 的值。\n\n最后回答询问只需要查找查找值 $cnt[t]$，其中 $t$ 为如果存在这样的状态就是状态对应的模式串，如果不存在答案就为 $0$。单次查询的时间复杂度为 $O(length(P))$。\n\n### 第一次出现的位置\n\n> 给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）。\n\n我们再构造一个后缀自动机。我们对自动机中的所有状态预处理位置 $firstpos$。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。\n\n为了维护 $firstpos$ 这些位置，我们将原函数扩展为 `sa_extend()`。当我们创建新状态 $cur$ 时，我们令：\n\n$$\nfirstpos(cur)=len(cur)-1\n$$\n\n；当我们将顶点 $q$ 复制到 $clone$ 时，我们令：\n\n$$\nfirstpos(clone)=firstpos(q)\n$$\n\n（因为值的唯一其它选项 $firstpos(cur)$ 肯定太大了）。\n\n那么查询的答案就是 $firstpos(t)-length(P)+1$，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(length(P))$ 的时间。\n\n### 所有出现的位置\n\n> 问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。\n\n我们还是为文本串 $T$ 构造后缀自动机。与上一个问题相似地，我们为所有状态计算位置 $firstpos$。\n\n如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。\n\n因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。\n\n这种变通方案的时间复杂度为 $O(answer(P))$，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。\n\n我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。\n\n此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 `is_clone`，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。\n\n以下是实现的框架：\n\n```cpp\nstruct state {\n    ...\n    bool is_clone;\n    int first_pos;\n    vector<int> inv_link;\n};\n\n// 在构造后缀自动机后\nfor (int v = 1; v < sz; v++) {\n    st[st[v].link].inv_link.push_back(v);\n}\n\n// 输出所有出现位置\nvoid output_all_occurrences(int v, int P_length) {\n    if (!st[v].is_clone)\n        cout << st[v].first_pos - P_length + 1 << endl;\n    for (int u : st[v].inv_link)\n        output_all_occurrences(u, P_length);\n}\n```\n\n### 最短的没有出现的字符串\n\n> 给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。\n\n我们在字符串 $S$ 的后缀自动机上做动态规划。\n\n令 $d[v]$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$，想找到不连续的转移需要添加的最小字符数量。计算 $d[v]$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d[v]=1$。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：\n\n$$\nd[v]=1+\\min_{w(v,\\,w,\\,c)\\in SA}d[w]\n$$\n\n问题的答案就是 $d[t_0]$，字符串可以通过计算过的数组 $d[]$ 逆推回去。\n\n### 两个字符串的最长公共子串\n\n> 给定两个字符串 $S$ 和 $T$，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$。\n\n我们为字符串 $S$ 构造后缀自动机。\n\n我们现在处理字符串 $T$，对于每一个前缀都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。\n\n为了达到这一目的，我们使用两个变量，**当前状态** $v$ 和 **当前长度** $l$。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。\n\n一开始 $v=t_0$ 且 $l=0$，即，匹配为空串。\n\n现在我们来描述如何添加一个字符 $T[i]$ 并为其重新计算答案：\n\n- 如果存在一个从 $v$ 到字符 $T[i]$ 的转移，我们只需要转移并让 $l$ 自增一。\n- 如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照以下后缀链接进行转移：  \n\n$$\nv=link(v)\n$$\n\n   与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。\n\n- 如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$，直到我们找到一个转移或到达虚拟状态 $-1$（这意味着字符 $T[i]$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$）。\n\n问题的答案就是所有 $l$ 的最大值。\n\n这一部分的时间复杂度为 $O(length(T))$，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。\n\n代码实现：\n\n```cpp\nstring lcs (string S, string T) {\n    sa_init();\n    for (int i = 0; i < S.size(); i++)\n        sa_extend(S[i]);\n\n    int v = 0, l = 0, best = 0, bestpos = 0;\n    for (int i = 0; i < T.size(); i++) {\n        while (v && !st[v].next.count(T[i])) {\n            v = st[v].link ;\n            l = st[v].length ;\n        }\n        if (st[v].next.count(T[i])) {\n            v = st [v].next[T[i]];\n            l++;\n        }\n        if (l > best) {\n            best = l;\n            bestpos = i;\n        }\n    }\n    return t.substr(bestpos - best + 1, best);\n}\n```\n\n### 多个字符串间的最长公共子串\n\n> 给定 $k$ 个字符串 $S_i$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$。\n\n我们将所有的子串连接成一个较长的字符串 $T$，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：\n\n$$\nT=S_1+D_1+S_2+D_2+\\cdots+S_k+D_k.\n$$\n\n然后为字符串 $T$ 构造后缀自动机。\n\n现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则后缀自动机中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\\,\\ldots,\\,D_{j-1},\\,D_{j+1},\\,\\ldots,\\,D_k$ 开始的路径。\n\n因此我们需要计算可达性，它告诉我们对于自动机中的每个状态和每个字符 $D_i$ 是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 与动态规划计算。在此之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。\n\n## 例题\n\n- SPOJ #7258 SUBLEX\n- [HihoCoder #1441 : 后缀自动机一 · 基本概念](http://hihocoder.com/problemset/problem/1441)\n\n## 相关资料\n\n我们先给出与后缀自动机有关的最初的一些文献：\n\n-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear \n      Size Finite Automata for the Set of All Subwords of a Word. An Outline of \n      Results** [1983]\n-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton \n      Recognizing the Subwords of a Text** [1984]\n- Maxime Crochemore. **Optimal Factor Transducers** [1985]\n- Maxime Crochemore. **Transducers and Repetitions** [1986]\n- A. Nerode. **Linear automaton transformations** [1958]\n\n另外，在更新的一些资源里，在很多关于字符串算法的书中，都能找到这个主题：\n\n- Maxime Crochemore, Rytter Wowjcieh. **Jewels of Stringology** [2002]\n- Bill Smyth. **Computing Patterns in Strings** [2003]\n- Bill Smith. **Methods and algorithms of calculations on lines** [2006]\n\n另外，还有一些资料：\n\n- 《后缀自动机》，陈立杰。\n- 《后缀自动机在字典树上的拓展》，刘研绎。\n- 《后缀自动机及其应用》，张天扬。\n- <https://www.cnblogs.com/zinthos/p/3899679.html>\n- <https://codeforces.com/blog/entry/20861>\n- <https://zhuanlan.zhihu.com/p/25948077>\n\n* * *\n\n**本页面主要译自博文\n[Суффиксный автомат](http://e-maxx.ru/algo/suffix_automata) 与其英文翻译版 [Suffix Automaton](https://cp-algorithms.com/string/suffix-automaton.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。**\n","source":"_posts/perf.md","raw":"---\ntitle: MD 解析器性能测试 + 查锅\ndate: 2018-09-21 22:25:06\ntags:\nmathjax: true\n---\n**后缀自动机**是一个能解决许多字符串相关问题的有力的数据结构。\n\n举个例子，字符串问题：\n\n- 在另一个字符串中搜索一个字符串的所有出现位置。\n- 计算给定的字符串中有多少个不同的子串。\n\n以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。\n\n直观上，字符串的后缀自动机可以理解为给定字符串的**所有子串**的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造后缀自动机的时间复杂度仅为 $O(n)$（这里我们将字符集的大小 $k$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\\log k)$）。\n\n## 后缀自动机的定义\n\n给定字符串 $s$ 的后缀自动机是一个接受所有字符串 $s$ 的后缀的最小 **DFA**（确定性有限自动机或确定性有限状态自动机）。\n\n换句话说：\n\n- 后缀自动机是一张有向无环图。顶点被称作**状态**，边被称作状态间的**转移**。\n- 一个状态 $t_0$ 为**初始状态**，它必定为这张图的源点（其它各点均与 $t_0$ 联通）。\n- 每个**转移**都标有一些字母。从一个顶点出发的所有转移均**不同**。\n- 一个或多个状态为**终止状态**。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到一个终止状态的路径构成。\n- 后缀自动机是所有满足上述条件的自动机中顶点数最少的一个。\n\n### 子串的性质\n\n后缀自动机最简单和最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个**子串**。反之每个 $s$ 的子串对应于从 $t_0$ 开始的某条路径。\n\n为了简化表达，我们将会说子串**对应于**一条路径（从 $t_0$ 开始且一些标号构成这个子串）。反过来我们说任意一条路径**对应于**它的标号构成的字符串。\n\n一条或多条路径可以到达一个状态，因此我们说一个状态对应于字符串的集合，这也对应于那些路径。\n\n### 构造后缀自动机的实例\n\n我们将会在这里展示一些简单的字符串的后缀自动机。\n\n我们用蓝色表示初始状态，用绿色表示终止状态。\n\n对于字符串 $s=``\"$：\n\n![](./SA.pdf.svg)\n\n对于字符串 $s=``a\\!\"$：\n\n![](./SAa.pdf.svg)\n\n对于字符串 $s=``aa\\!\"$：\n\n![](./SAaa.pdf.svg)\n\n对于字符串 $s=``ab\\!\"$：\n\n![](./SAab.pdf.svg)\n\n对于字符串 $s=``abb\\!\"$：\n\n![](./SAabb.pdf.svg)\n\n对于字符串 $s=``abbb\\!\"$：\n\n![](./SAabbb.pdf.svg)\n\n## 在线性时间内构造后缀自动机\n\n在我们描述线性时间内构造后缀自动机的算法之前，我们需要引入几个对理解构造过程非常重要的新概念并简单证明。\n\n### 结束位置 <script type=\"math/tex\">endpos</script>\n\n<p>考虑字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 的任意非空子串 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> ，我们记 <span><span class=\"MathJax_Preview\">endpos(t)</span><script type=\"math/tex\">endpos(t)</script></span> 为在字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 中 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 <span><span class=\"MathJax_Preview\">``abcbc\\!\"</span><script type=\"math/tex\">``abcbc\\!\"</script></span>，我们有 <span><span class=\"MathJax_Preview\">endpos(``bc\\!\")=2,\\,4</span><script type=\"math/tex\">endpos(``bc\\!\")=2,\\,4</script></span>。</p>\n\n当两个子串 $t_1$ 与 $t_2$ 的末尾集合相等时我们称它们是 $endpos$ 等价的：即 $endpos(t_1)=endpos(t_2)$。这样所有字符串 $s$ 的非空子串都可以根据它们的 **$endpos$** 集合被分为几个**等价类**。\n\n显然，在后缀自动机中的每个状态对应于一个或多个 $endpos$ 相同的子串。换句话说，后缀自动机中的状态数等于所有子串的等价类的个数，加上初始状态。后缀自动机的状态个数等价于 $endpos$ 相同的一个或多个子串。\n\n我们稍后将会用这个假设介绍构造后缀自动机的算法。在那时我们将会发现，后缀自动机需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（这篇文章不会证明后缀自动机的最小性）。\n\n由 $endpos$ 的值我们可以得到一些重要结论：\n\n> **引理 1：**当且仅当字符串 $u$ 以 $w$ 的一个后缀的形式出现在字符串 $s$ 中时，两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）是 $endpos$ 等价的。\n\n引理显然成立。如果 $u$ 和 $v$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 值相等。\n\n> **引理 2：**考虑两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）。则它们的 $endpos$ 构成的集合要么完全没有交集，要么 $endpos(w)$ 是 $endpos(u)$ 的一个子集。并且这依赖于 $u$ 是否为 $w$ 的一个后缀。即：\n>\n> $$\n> \\begin{cases}\n>  endpos(w)\\subseteq endpos(u)&\\text{若 $u$ 为 $w$ 的一个后缀}\\\\\n>  endpos(w)\\cap endpos(u)=\\emptyset&\\text{另一种情况}\\\\\n> \\end{cases}\n> $$\n\n证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 都在一个位置结束，即 $u$ 是 $w$ 的一个后缀。但是如果如此在每次 $w$ 出现的位置子串 $u$ 也会出现，这意味着 $endpos(w)$ 是 $endpos(u)$ 的一个子集。\n\n> **引理 3：**考虑一个 $endpos$ 等价类。将类中的所有子串按长度非递增的顺序排序。即每个子串都会比它前一个子串短，与此同时每个子串也是它前一个子串的一个后缀。换句话说，同一等价类中的所有子串均互为后缀，且子串的长度恰好覆盖整个区间 $[x,\\,y]$。\n\n证明：固定一些 $endpos$ 等价类。如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。\n\n由引理 1，两个不同的 $endpos$ 等价字符串中较短的一个总是较长的一个的真后缀。因此，等价类中不可能有两个等长的字符串。\n\n记 $w$ 为等价类中最长的字符串，类似地，记 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[length(u),\\,length(w)]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中。因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀与字符串 $w$ $endpos$ 等价。\n\n### 后缀链接 <script type=\"math/tex\">link</script>\n\n考虑后缀自动机中满足 $v\\ne t_0$ 的一些状态。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。\n\n我们还知道字符串 $w$ 的前几个后缀（如果我们用长度降序考虑这些后缀）在这个等价类中全部被包含，且所有其它后缀（至少一个—空后缀）在其它的等价类中。我们记 $t$ 为最大的这样的后缀，然后用后缀链接连到 $t$ 上。\n\n换句话说，一个**后缀链接** $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。\n\n以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串），为了方便我们规定 $endpos(t)=\\{-1,\\,0,\\,\\ldots,\\,length(s)-1\\}$。\n\n> **引理 4：**所有后缀链接构成一棵根节点为 $t_0$ 的树。\n\n证明：考虑任意满足 $v\\ne t_0$ 的状态，一个后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（根据后缀链接的定义和引理 3）。因此，通过在后缀链接上移动，我们早晚会到达对应空串的初始状态 $t_0$。\n\n> **引理 5：**如果我们使用集合 $endpos$ 构造一棵树（所有子节点的集合为父节点的子集），则这个结构由后缀链接连接起来。\n\n证明：由引理 2，我们可以用 $endpos$ 集合构造一棵树（因为两个集合要么完全没有交集要么互为子集）。\n\n我们现在考虑任意满足 $v\\ne t_0$ 的状态和它的后缀链接 $link(v)$，由后缀链接和引理 2，我们可以得到\n\n$$\nendpos(v)\\subseteq endpos(link(v))\n$$\n\n，这与前面的引理证明了以下断言成立：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。\n\n以下是对于字符串 $``abcbc\\!\"$ 构造后缀自动机时产生的后缀链接树的一个**例子**，节点被标记为对应等价类中最长的子串。\n\n![](./SA_suffix_links.pdf.svg)\n\n### 小结\n\n在学习算法本身前，我们对之前学过的知识进行一下总结，并引入一些辅助记号。\n\n- $s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；\n- 后缀自动机由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；\n- 对于每一个状态 $v$，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$。那么所有对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),\\,len(v)]$ 中的每一个整数。\n- 对于任意满足 $v\\ne t_0$ 的状态，定义后缀链接为连接到对应字符串 $longest(v)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树，与此同时，这棵树形成了 $endpos$ 集合间的包含关系。\n- 我们可以对 $v\\ne t_0$ 的状态使用后缀链接 $link(v)$ 解释 $minlen(v)$ 如下：\n\n$$\nminlen(v)=len(link(v))+1.\n$$\n\n- 如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，早晚都会到达初始状态 $t_0$。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),\\,len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,\\,len(v_0)]$。\n\n### 算法\n\n现在我们可以学习算法本身了。这个算法是**在线**算法，这意味着我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护后缀自动机。\n\n为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的一个转移列表，我们不会标记终止状态（但是我们稍后会展示在构造后缀自动机后如何分配这些标记）。\n\n一开始后缀自动机只包含一个状态 $t_0$，编号为 $0$（其它状态的编号为 $1,\\,2,\\,\\ldots$）。为了方便，我们分配给它 $len=0$ 和 $link=-1$（$-1$ 表示一个虚拟的不存在的状态）。\n\n现在整个任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：\n\n- 令 $last$ 为对应添加字符 $c$ 之前的整个字符串（一开始我们设置 $last=0$ 且我们会在算法的最后一步对应地更新 $last$）。\n- 创建一个新的状态 $cur$，并将 $len(cur)$ 赋值为 $len(last)+1$，在这时 $link(cur)$ 的值还未知。\n- 现在我们按以下流程进行：我们从状态 $last$ 开始。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的后缀链接，我们就停下来，并将这个状态标记为 $p$。\n- 如果没有找到这样的状态 $p$，我们就到达了虚拟状态 $-1$，我们将 $link(cur)$ 赋值为 $-1$ 并退出。\n- 假设现在我们找到了一个状态 $p$，其可以转移到字符 $c$，我们将这个状态转移到的状态标记为 $q$。\n- 现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$，要么不是。\n- 如果 $len(p)+1=len(q)$，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。\n-   否则就会有些复杂。需要**复制**状态 $q$：我们创建一个新的状态 $clone$，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$。  \n    复制之后，我们将后缀链接从 $cur$ 指向 $clone$，也从 $q$ 指向 $clone$。  \n    最终我们需要使用后缀链接从状态 $p$ 返回，因为存在一条通过 $c$ 到状态 $q$ 的转移，并在此过程中重定向所有状态到状态 $clone$。\n- 以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$。\n\n如果我们还想知道哪些状态是**终止状态**而哪些不是，我们可以在为字符串 $s$ 构造完完整的后缀自动机后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会精确地标记字符串 $s$ 的所有后缀，这些状态恰好是终止状态。\n\n在下一部分，我们将观察算法每一步的细节，并证明它的**正确性**。\n\n现在，我们只注意到，因为我们只为 $s$ 的每个字符创建一个或两个新状态所以后缀自动机只包含**线性个**状态。\n\n转移个数是线性规模的，以及总体上算法的运行时间是线性规模的，这两点还不那么清\n楚。\n\n### 正确性证明\n\n- 若一个转移 $(p,\\,q)$ 满足 $len(p)+1=len(q)$ 则我们称这个转移是**连续的**。否则，即当 $len(p)+1<len(q)$ 时，这个转移被称为**不连续的**。  从算法描述中可以看出，连续的和非连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，非连续的转移可能会改变（转移边的端点可能会改变）。\n- 为了避免引起歧义，我们记向后缀自动机中插入当前字符 $c$ 之前的字符串为 $s$。\n- 算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。\n- 在创建一个新的状态之后，我们会从对应于整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个从字符 $c$ 到新状态 $cur$ 的转移。然而我我们只能添加与原来已存在的转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。\n- 最简单的情况是我们到达了虚拟状态 $-1$，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$。\n- 第二种情况下，我们找到了现有的转移 $(p,\\,q)$。这意味着我们尝试向自动机内添加一个**已经存在的**字符串 $x+c$（其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。  然而，有一个难点。从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$，即这个状态的 $len$ 应该是 $len(p)+1$。然而还不存在这样的状态，即 $len(q)>len(p)+1$。这种情况下，我们必须要通过拆开状态 $q$ 来创建一个这样的状态。\n- 如果转移 $(p,\\,q)$ 是连续的，那么 $len(q)=len(p)+1$。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$。\n-   否则转移是不连续的，即 $len(q)>len(p)+1$，这意味着状态 $q$ 不只对应于长度为$len(p)+1$ 的后缀 $s+c$，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。  \n    我们如何拆开一个状态呢？我们**复制**状态 $q$，产生一个状态 $clone$，我们将 $len(clone)$ 赋值为 $len(p)+1$。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$。  \n    在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$。  \n    最后一步我们将一些到 $q$ 转移重定向到 $clone$。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$（其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从顶点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。\n\n### 对操作次数为线性的证明\n\n首先我们假设字符集大小为**常数**。如果字符集大小不是常数，后缀自动机的时间复杂度就不是线性的。从一个顶点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $k$ 为字符集的大小，则算法的渐进时间复杂度为 $O(n\\log k)$，空间复杂度为 $O(n)$。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个顶点的转移存储为长度为 $k$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$，空间复杂度为 $O(nk)$。\n\n所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移—这些操作的时间复杂度都为 $O(1)$。\n\n如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：\n\n- 第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。\n- 第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。\n- 第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。\n\n我们使用后缀自动机的大小（状态数和转移数）为**线性的**的事实（对状态数是线性的的证明就是算法本身，对状态数为线性的的证明将在稍后实现算法后给出）。\n\n因此上述**第一处和第二处**的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。\n\n还需为**第三处**估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$。我们记 $v=longest(p)$，这是一个字符串 $s$ 的后缀，每次迭代长度都递减—因为作为字符串 $s$ 的位置随着每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$ $(k\\ge2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。\n\n因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。\n\n### 实现\n\n首先，我们描述一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将会用一个 `map` 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\\log k)$ 的时间复杂度内处理整个字符串。\n\n```cpp\nstruct state {\n    int len, link;\n    map<char, int> next;\n};\n```\n\n后缀自动机本身将会存储在一个 `state` 结构体数组中。我们记录当前自动机的大小 `sz` 和变量 `last`，当前整个字符串对应的状态。\n\n```cpp\nconst int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n```\n\n我们定义一个函数来初始化后缀自动机（创建一个只有一个状态的后缀自动机）。\n\n```cpp\nvoid sa_init() {\n    st[0].len = 0;\n    st[0].link = -1;\n    sz++;\n    last = 0;\n}\n```\n\n最终我们给出主函数的实现—给当前行末增加一个字符，对应地重建自动机。\n\n```cpp\nvoid sa_extend(char c) {\n    int cur = sz++;\n    st[cur].len = st[last].len + 1;\n    int p = last;\n    while (p != -1 && !st[p].next.count(c)) {\n        st[p].next[c] = cur;\n        p = st[p].link;\n    }\n    if (p == -1) {\n        st[cur].link = 0;\n    } else {\n        int q = st[p].next[c];\n        if (st[p].len + 1 = st[q].len) {\n            st[cur].link = q;\n        } else {\n            int clone = sz++;\n            st[clone].len = st[p].len + 1;\n            st[clone].next = st[q].next;\n            st[clone].link = st[q].link;\n            while (p != -1 && st[p].next[c] == q) {\n                st[p].next[c] = clone;\n                p = st[p].link;\n            }\n            st[q].link = st[cur].link = clone;\n        }\n    }\n    last = cur;\n}\n```\n\n正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(nk)$，其中 $k$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小 $k$ 任意的后缀自动机。但是这样你需要为每一个状态储存一个大小为 $k$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。\n\n## 更多的性质\n\n### 状态数\n\n对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的状态数**不会超过 $2n-1$** （假设 $n\\ge2$）。\n\n对上述结论的证明就是算法本身，因为一开始自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。\n\n然而我们也能在**不知道这个算法**的情况下**展示**这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。另外这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部顶点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部顶点的度数大于一的树，并且叶子节点的个数不超过 $n$。因此这样的树里有不超过 $2n-1$ 个节点。\n\n对于每个确定的 $n$，状态数的上界是确定的。一个可能的字符串是：\n\n$$\n``abbb\\ldots bbb\\!\"\n$$\n\n从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。\n\n### 转移数\n\n对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的转移数**不会超过 $3n-4$**（假设 $n\\ge 3$）。\n\n证明如下：\n\n我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的最长路径的生成树。生成树的骨架只包含连续的边，因此数量少于状态数，即，边数不会超过 $2n-2$。\n\n现在我们来估计非连续的转移的数量。令当前非连续转移为 $(p,\\,q)$，其字符为 $c$。我们取它的对应字符串 $u+c+w$，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径，$w$ 对应于从 $p$ 到任意终止状态的最长路径。一方面，对于每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$（因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$。\n\n将以上两个估计值结合起来，我们可以得到上界 $3n-3$。然而，最大的状态数只能在测试数据 $``abbb\\ldots bbb\\!\"$ 中产生，这个测试数据的转移数量显然少于 $3n-3$，我们可以获得更为紧确的后缀自动机的转移数的上界：$3n-4$。\n\n上界可以通过字符串\n\n$$\n``abbb\\ldots bbbc\\!\"\n$$\n\n达到。\n\n## 应用\n\n下面我们来看一下一些可以用后缀自动机解决的问题。为了简单，我们假设字符集的大小 $k$ 为常数，允许我们认为增加一个字符和遍历的复杂度为常数。\n\n### 检查字符串是否出现\n\n> 给一个文本串 $T$ 和多个模式串 $P$，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。\n\n我们在 $O(length(T))$ 的时间内为文本串 $T$ 构造后缀自动机。为了检查模式串 $T$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$，那么模式串在 $T$ 中出现过。因此\n\n对于每个字符串 $P$ 算法的时间复杂度为 $O(length(P))$。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。\n\n### 不同子串个数\n\n> 给一个字符串 $S$，计算不同子串的个数。\n\n为字符串 $S$ 构造后缀自动机。\n\n每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。\n\n考虑到后缀自动机为有向无环图，不同路径的条数可以使用动态规划计算。\n\n即，令 $d[v]$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程式：\n\n$$\nd[v]=1+\\sum_{w:(v,\\,w,\\,c)\\in SA}d[w]\n$$\n\n即，$d[v]$ 可以表示为所有 $v$ 的转移的末端的和。\n\n所以不同子串的个数为 $d[t_0]-1$（因为要去掉空子串）。\n\n总时间复杂度为：$O(length(S))$。\n\n### 所有不同子串的总长度\n\n> 给定一个字符串 $S$，计算所有不同子串的总长度。\n\n本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d[v]$ 和它们的总长度 $ans[v]$。\n\n我们已经在上一题中介绍了如何计算 $d[v]$。$ans[v]$ 的值可以使用通过以下递推式计算：\n\n$$\nans[v]=\\sum_{w:(v,\\,w,\\,c)\\in DAWG}d[w]+ans[w]\n$$\n\n我们取每个邻接顶点 $w$ 的答案，并加上 $d[w]$（因为从状态 $v$ 出发的子串都增加了一个字符）。\n\n算法的时间复杂度仍然是 $O(length(S))$。\n\n### 字典序第 <script type=\"math/tex\">k</script> 大子串\n\n> 给定一个字符串 $S$。多组询问，每组询问给定一个数 $K_i$，查询所有子串中词典序第 $k$ 大的子串。\n\n解决这个问题的思路基于前两个问题的思路。字典序第 $k$ 大的子串对应于后缀自动机中字典序第 $k$ 大的路径。因此在计算每个状态的路径数后，我们可以很容易地从后缀自动机的根开始找到第 $k$ 大的路径。\n\n预处理的时间复杂度为 $O(length(S))$，单次查询的复杂度为 $O(length(ans)\\cdot k)$（其中 $ans$ 是查询的答案，$k$ 为字符集的大小）。\n\n### 最小循环移位\n\n> 给定一个字符串 $S$。找出字典序最小的循环移位。\n\n我们为字符串 $S+S$ 构造后缀自动机。则后缀自动机本身将包含字符串 $S$ 的所有循环移位作为路径。\n\n所以问题简化为寻找最小的长度为 $length(S)$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。\n\n总的时间复杂度为 $O(length(S))$。\n\n### 出现次数\n\n> 对于一个给定的文本串 $T$，有多组询问，每组询问给一个模式串 $P$，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。\n\n我们为文本串 $T$ 构造后缀自动机。\n\n接下来我们做以下的预处理：对于自动机中的每个状态 $v$，预处理值等于 $endpos(v)$ 这个集合大小的 $cnt[v]$。事实上对应于同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。\n\n然而我们不能明确的构造集合 $endpos$，因此我们只考虑它们的大小 $cnt$。\n\n为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$），我们用 $cnt=1$ 初始化它。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt[v]$ 的值加到后缀链接上，即：\n\n$$\ncnt[link(v)]+=cnt[v]\n$$\n\n这样做每个状态的答案都是正确的。\n\n为什么这是正确的？通过复制获得的状态，恰好是 $length(T)$，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$，其它状态的 $cnt$ 值赋为 $0$。\n\n接下来我们对每一个 $v$ 执行以下操作：$cnt[link(v)]+=cnt[v]$。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt[v]$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt[v]$ 次。\n\n为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到**一个**其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。\n\n因此，我们可以在 $O(length(T))$ 的时间内计算出所有状态的 $cnt$ 的值。\n\n最后回答询问只需要查找查找值 $cnt[t]$，其中 $t$ 为如果存在这样的状态就是状态对应的模式串，如果不存在答案就为 $0$。单次查询的时间复杂度为 $O(length(P))$。\n\n### 第一次出现的位置\n\n> 给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）。\n\n我们再构造一个后缀自动机。我们对自动机中的所有状态预处理位置 $firstpos$。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。\n\n为了维护 $firstpos$ 这些位置，我们将原函数扩展为 `sa_extend()`。当我们创建新状态 $cur$ 时，我们令：\n\n$$\nfirstpos(cur)=len(cur)-1\n$$\n\n；当我们将顶点 $q$ 复制到 $clone$ 时，我们令：\n\n$$\nfirstpos(clone)=firstpos(q)\n$$\n\n（因为值的唯一其它选项 $firstpos(cur)$ 肯定太大了）。\n\n那么查询的答案就是 $firstpos(t)-length(P)+1$，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(length(P))$ 的时间。\n\n### 所有出现的位置\n\n> 问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。\n\n我们还是为文本串 $T$ 构造后缀自动机。与上一个问题相似地，我们为所有状态计算位置 $firstpos$。\n\n如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。\n\n因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。\n\n这种变通方案的时间复杂度为 $O(answer(P))$，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。\n\n我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。\n\n此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 `is_clone`，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。\n\n以下是实现的框架：\n\n```cpp\nstruct state {\n    ...\n    bool is_clone;\n    int first_pos;\n    vector<int> inv_link;\n};\n\n// 在构造后缀自动机后\nfor (int v = 1; v < sz; v++) {\n    st[st[v].link].inv_link.push_back(v);\n}\n\n// 输出所有出现位置\nvoid output_all_occurrences(int v, int P_length) {\n    if (!st[v].is_clone)\n        cout << st[v].first_pos - P_length + 1 << endl;\n    for (int u : st[v].inv_link)\n        output_all_occurrences(u, P_length);\n}\n```\n\n### 最短的没有出现的字符串\n\n> 给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。\n\n我们在字符串 $S$ 的后缀自动机上做动态规划。\n\n令 $d[v]$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$，想找到不连续的转移需要添加的最小字符数量。计算 $d[v]$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d[v]=1$。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：\n\n$$\nd[v]=1+\\min_{w(v,\\,w,\\,c)\\in SA}d[w]\n$$\n\n问题的答案就是 $d[t_0]$，字符串可以通过计算过的数组 $d[]$ 逆推回去。\n\n### 两个字符串的最长公共子串\n\n> 给定两个字符串 $S$ 和 $T$，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$。\n\n我们为字符串 $S$ 构造后缀自动机。\n\n我们现在处理字符串 $T$，对于每一个前缀都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。\n\n为了达到这一目的，我们使用两个变量，**当前状态** $v$ 和 **当前长度** $l$。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。\n\n一开始 $v=t_0$ 且 $l=0$，即，匹配为空串。\n\n现在我们来描述如何添加一个字符 $T[i]$ 并为其重新计算答案：\n\n- 如果存在一个从 $v$ 到字符 $T[i]$ 的转移，我们只需要转移并让 $l$ 自增一。\n- 如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照以下后缀链接进行转移：  \n\n$$\nv=link(v)\n$$\n\n   与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。\n\n- 如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$，直到我们找到一个转移或到达虚拟状态 $-1$（这意味着字符 $T[i]$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$）。\n\n问题的答案就是所有 $l$ 的最大值。\n\n这一部分的时间复杂度为 $O(length(T))$，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。\n\n代码实现：\n\n```cpp\nstring lcs (string S, string T) {\n    sa_init();\n    for (int i = 0; i < S.size(); i++)\n        sa_extend(S[i]);\n\n    int v = 0, l = 0, best = 0, bestpos = 0;\n    for (int i = 0; i < T.size(); i++) {\n        while (v && !st[v].next.count(T[i])) {\n            v = st[v].link ;\n            l = st[v].length ;\n        }\n        if (st[v].next.count(T[i])) {\n            v = st [v].next[T[i]];\n            l++;\n        }\n        if (l > best) {\n            best = l;\n            bestpos = i;\n        }\n    }\n    return t.substr(bestpos - best + 1, best);\n}\n```\n\n### 多个字符串间的最长公共子串\n\n> 给定 $k$ 个字符串 $S_i$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$。\n\n我们将所有的子串连接成一个较长的字符串 $T$，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：\n\n$$\nT=S_1+D_1+S_2+D_2+\\cdots+S_k+D_k.\n$$\n\n然后为字符串 $T$ 构造后缀自动机。\n\n现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则后缀自动机中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\\,\\ldots,\\,D_{j-1},\\,D_{j+1},\\,\\ldots,\\,D_k$ 开始的路径。\n\n因此我们需要计算可达性，它告诉我们对于自动机中的每个状态和每个字符 $D_i$ 是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 与动态规划计算。在此之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。\n\n## 例题\n\n- SPOJ #7258 SUBLEX\n- [HihoCoder #1441 : 后缀自动机一 · 基本概念](http://hihocoder.com/problemset/problem/1441)\n\n## 相关资料\n\n我们先给出与后缀自动机有关的最初的一些文献：\n\n-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. **Linear \n      Size Finite Automata for the Set of All Subwords of a Word. An Outline of \n      Results** [1983]\n-   A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. **The Smallest Automaton \n      Recognizing the Subwords of a Text** [1984]\n- Maxime Crochemore. **Optimal Factor Transducers** [1985]\n- Maxime Crochemore. **Transducers and Repetitions** [1986]\n- A. Nerode. **Linear automaton transformations** [1958]\n\n另外，在更新的一些资源里，在很多关于字符串算法的书中，都能找到这个主题：\n\n- Maxime Crochemore, Rytter Wowjcieh. **Jewels of Stringology** [2002]\n- Bill Smyth. **Computing Patterns in Strings** [2003]\n- Bill Smith. **Methods and algorithms of calculations on lines** [2006]\n\n另外，还有一些资料：\n\n- 《后缀自动机》，陈立杰。\n- 《后缀自动机在字典树上的拓展》，刘研绎。\n- 《后缀自动机及其应用》，张天扬。\n- <https://www.cnblogs.com/zinthos/p/3899679.html>\n- <https://codeforces.com/blog/entry/20861>\n- <https://zhuanlan.zhihu.com/p/25948077>\n\n* * *\n\n**本页面主要译自博文\n[Суффиксный автомат](http://e-maxx.ru/algo/suffix_automata) 与其英文翻译版 [Suffix Automaton](https://cp-algorithms.com/string/suffix-automaton.html) 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。**\n","slug":"perf","published":1,"updated":"2018-09-21T23:17:47.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmcms7jj0005ns10bikkasix","content":"<p><strong>后缀自动机</strong>是一个能解决许多字符串相关问题的有力的数据结构。</p>\n<p>举个例子，字符串问题：</p>\n<ul>\n<li>在另一个字符串中搜索一个字符串的所有出现位置。</li>\n<li>计算给定的字符串中有多少个不同的子串。</li>\n</ul>\n<p>以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。</p>\n<p>直观上，字符串的后缀自动机可以理解为给定字符串的<strong>所有子串</strong>的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造后缀自动机的时间复杂度仅为 $O(n)$（这里我们将字符集的大小 $k$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\\log k)$）。</p>\n<h2 id=\"后缀自动机的定义\"><a href=\"#后缀自动机的定义\" class=\"headerlink\" title=\"后缀自动机的定义\"></a>后缀自动机的定义</h2><p>给定字符串 $s$ 的后缀自动机是一个接受所有字符串 $s$ 的后缀的最小 <strong>DFA</strong>（确定性有限自动机或确定性有限状态自动机）。</p>\n<p>换句话说：</p>\n<ul>\n<li>后缀自动机是一张有向无环图。顶点被称作<strong>状态</strong>，边被称作状态间的<strong>转移</strong>。</li>\n<li>一个状态 $t_0$ 为<strong>初始状态</strong>，它必定为这张图的源点（其它各点均与 $t_0$ 联通）。</li>\n<li>每个<strong>转移</strong>都标有一些字母。从一个顶点出发的所有转移均<strong>不同</strong>。</li>\n<li>一个或多个状态为<strong>终止状态</strong>。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到一个终止状态的路径构成。</li>\n<li>后缀自动机是所有满足上述条件的自动机中顶点数最少的一个。</li>\n</ul>\n<h3 id=\"子串的性质\"><a href=\"#子串的性质\" class=\"headerlink\" title=\"子串的性质\"></a>子串的性质</h3><p>后缀自动机最简单和最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个<strong>子串</strong>。反之每个 $s$ 的子串对应于从 $t_0$ 开始的某条路径。</p>\n<p>为了简化表达，我们将会说子串<strong>对应于</strong>一条路径（从 $t_0$ 开始且一些标号构成这个子串）。反过来我们说任意一条路径<strong>对应于</strong>它的标号构成的字符串。</p>\n<p>一条或多条路径可以到达一个状态，因此我们说一个状态对应于字符串的集合，这也对应于那些路径。</p>\n<h3 id=\"构造后缀自动机的实例\"><a href=\"#构造后缀自动机的实例\" class=\"headerlink\" title=\"构造后缀自动机的实例\"></a>构造后缀自动机的实例</h3><p>我们将会在这里展示一些简单的字符串的后缀自动机。</p>\n<p>我们用蓝色表示初始状态，用绿色表示终止状态。</p>\n<p>对于字符串 $s=<code></code>“$：</p>\n<p><img src=\"./SA.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>a!“$：</p>\n<p><img src=\"./SAa.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>aa!“$：</p>\n<p><img src=\"./SAaa.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>ab!“$：</p>\n<p><img src=\"./SAab.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>abb!“$：</p>\n<p><img src=\"./SAabb.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>abbb!“$：</p>\n<p><img src=\"./SAabbb.pdf.svg\" alt=\"\"></p>\n<h2 id=\"在线性时间内构造后缀自动机\"><a href=\"#在线性时间内构造后缀自动机\" class=\"headerlink\" title=\"在线性时间内构造后缀自动机\"></a>在线性时间内构造后缀自动机</h2><p>在我们描述线性时间内构造后缀自动机的算法之前，我们需要引入几个对理解构造过程非常重要的新概念并简单证明。</p>\n<h3 id=\"结束位置-endpos\"><a href=\"#结束位置-endpos\" class=\"headerlink\" title=\"结束位置 endpos\"></a>结束位置 <script type=\"math/tex\">endpos</script></h3><p>考虑字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 的任意非空子串 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> ，我们记 <span><span class=\"MathJax_Preview\">endpos(t)</span><script type=\"math/tex\">endpos(t)</script></span> 为在字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 中 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 <span><span class=\"MathJax_Preview\"><code>abcbc\\!&quot;&lt;/span&gt;&lt;script type=&quot;math/tex&quot;&gt;</code>abcbc!“</span>，我们有 <span><span class=\"MathJax_Preview\">endpos(<code>bc\\!&quot;)=2,\\,4&lt;/span&gt;&lt;script type=&quot;math/tex&quot;&gt;endpos(</code>bc!“)=2,\\,4</span>。</span></span></p>\n\n<p>当两个子串 $t_1$ 与 $t_2$ 的末尾集合相等时我们称它们是 $endpos$ 等价的：即 $endpos(t_1)=endpos(t_2)$。这样所有字符串 $s$ 的非空子串都可以根据它们的 <strong>$endpos$</strong> 集合被分为几个<strong>等价类</strong>。</p>\n<p>显然，在后缀自动机中的每个状态对应于一个或多个 $endpos$ 相同的子串。换句话说，后缀自动机中的状态数等于所有子串的等价类的个数，加上初始状态。后缀自动机的状态个数等价于 $endpos$ 相同的一个或多个子串。</p>\n<p>我们稍后将会用这个假设介绍构造后缀自动机的算法。在那时我们将会发现，后缀自动机需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（这篇文章不会证明后缀自动机的最小性）。</p>\n<p>由 $endpos$ 的值我们可以得到一些重要结论：</p>\n<blockquote>\n<p><strong>引理 1：</strong>当且仅当字符串 $u$ 以 $w$ 的一个后缀的形式出现在字符串 $s$ 中时，两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）是 $endpos$ 等价的。</p>\n</blockquote>\n<p>引理显然成立。如果 $u$ 和 $v$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 值相等。</p>\n<blockquote>\n<p><strong>引理 2：</strong>考虑两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）。则它们的 $endpos$ 构成的集合要么完全没有交集，要么 $endpos(w)$ 是 $endpos(u)$ 的一个子集。并且这依赖于 $u$ 是否为 $w$ 的一个后缀。即：</p>\n<p>$$<br>\\begin{cases}<br> endpos(w)\\subseteq endpos(u)&amp;\\text{若 $u$ 为 $w$ 的一个后缀}\\<br> endpos(w)\\cap endpos(u)=\\emptyset&amp;\\text{另一种情况}\\<br>\\end{cases}<br>$$</p>\n</blockquote>\n<p>证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 都在一个位置结束，即 $u$ 是 $w$ 的一个后缀。但是如果如此在每次 $w$ 出现的位置子串 $u$ 也会出现，这意味着 $endpos(w)$ 是 $endpos(u)$ 的一个子集。</p>\n<blockquote>\n<p><strong>引理 3：</strong>考虑一个 $endpos$ 等价类。将类中的所有子串按长度非递增的顺序排序。即每个子串都会比它前一个子串短，与此同时每个子串也是它前一个子串的一个后缀。换句话说，同一等价类中的所有子串均互为后缀，且子串的长度恰好覆盖整个区间 $[x,\\,y]$。</p>\n</blockquote>\n<p>证明：固定一些 $endpos$ 等价类。如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。</p>\n<p>由引理 1，两个不同的 $endpos$ 等价字符串中较短的一个总是较长的一个的真后缀。因此，等价类中不可能有两个等长的字符串。</p>\n<p>记 $w$ 为等价类中最长的字符串，类似地，记 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[length(u),\\,length(w)]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中。因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀与字符串 $w$ $endpos$ 等价。</p>\n<h3 id=\"后缀链接-link\"><a href=\"#后缀链接-link\" class=\"headerlink\" title=\"后缀链接 link\"></a>后缀链接 <script type=\"math/tex\">link</script></h3><p>考虑后缀自动机中满足 $v\\ne t_0$ 的一些状态。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。</p>\n<p>我们还知道字符串 $w$ 的前几个后缀（如果我们用长度降序考虑这些后缀）在这个等价类中全部被包含，且所有其它后缀（至少一个—空后缀）在其它的等价类中。我们记 $t$ 为最大的这样的后缀，然后用后缀链接连到 $t$ 上。</p>\n<p>换句话说，一个<strong>后缀链接</strong> $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。</p>\n<p>以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串），为了方便我们规定 $endpos(t)={-1,\\,0,\\,\\ldots,\\,length(s)-1}$。</p>\n<blockquote>\n<p><strong>引理 4：</strong>所有后缀链接构成一棵根节点为 $t_0$ 的树。</p>\n</blockquote>\n<p>证明：考虑任意满足 $v\\ne t_0$ 的状态，一个后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（根据后缀链接的定义和引理 3）。因此，通过在后缀链接上移动，我们早晚会到达对应空串的初始状态 $t_0$。</p>\n<blockquote>\n<p><strong>引理 5：</strong>如果我们使用集合 $endpos$ 构造一棵树（所有子节点的集合为父节点的子集），则这个结构由后缀链接连接起来。</p>\n</blockquote>\n<p>证明：由引理 2，我们可以用 $endpos$ 集合构造一棵树（因为两个集合要么完全没有交集要么互为子集）。</p>\n<p>我们现在考虑任意满足 $v\\ne t_0$ 的状态和它的后缀链接 $link(v)$，由后缀链接和引理 2，我们可以得到</p>\n<p>$$<br>endpos(v)\\subseteq endpos(link(v))<br>$$</p>\n<p>，这与前面的引理证明了以下断言成立：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。</p>\n<p>以下是对于字符串 $<code></code>abcbc!“$ 构造后缀自动机时产生的后缀链接树的一个<strong>例子</strong>，节点被标记为对应等价类中最长的子串。</p>\n<p><img src=\"./SA_suffix_links.pdf.svg\" alt=\"\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在学习算法本身前，我们对之前学过的知识进行一下总结，并引入一些辅助记号。</p>\n<ul>\n<li>$s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；</li>\n<li>后缀自动机由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；</li>\n<li>对于每一个状态 $v$，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$。那么所有对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),\\,len(v)]$ 中的每一个整数。</li>\n<li>对于任意满足 $v\\ne t_0$ 的状态，定义后缀链接为连接到对应字符串 $longest(v)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树，与此同时，这棵树形成了 $endpos$ 集合间的包含关系。</li>\n<li>我们可以对 $v\\ne t_0$ 的状态使用后缀链接 $link(v)$ 解释 $minlen(v)$ 如下：</li>\n</ul>\n<p>$$<br>minlen(v)=len(link(v))+1.<br>$$</p>\n<ul>\n<li>如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，早晚都会到达初始状态 $t_0$。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),\\,len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,\\,len(v_0)]$。</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>现在我们可以学习算法本身了。这个算法是<strong>在线</strong>算法，这意味着我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护后缀自动机。</p>\n<p>为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的一个转移列表，我们不会标记终止状态（但是我们稍后会展示在构造后缀自动机后如何分配这些标记）。</p>\n<p>一开始后缀自动机只包含一个状态 $t_0$，编号为 $0$（其它状态的编号为 $1,\\,2,\\,\\ldots$）。为了方便，我们分配给它 $len=0$ 和 $link=-1$（$-1$ 表示一个虚拟的不存在的状态）。</p>\n<p>现在整个任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：</p>\n<ul>\n<li>令 $last$ 为对应添加字符 $c$ 之前的整个字符串（一开始我们设置 $last=0$ 且我们会在算法的最后一步对应地更新 $last$）。</li>\n<li>创建一个新的状态 $cur$，并将 $len(cur)$ 赋值为 $len(last)+1$，在这时 $link(cur)$ 的值还未知。</li>\n<li>现在我们按以下流程进行：我们从状态 $last$ 开始。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的后缀链接，我们就停下来，并将这个状态标记为 $p$。</li>\n<li>如果没有找到这样的状态 $p$，我们就到达了虚拟状态 $-1$，我们将 $link(cur)$ 赋值为 $-1$ 并退出。</li>\n<li>假设现在我们找到了一个状态 $p$，其可以转移到字符 $c$，我们将这个状态转移到的状态标记为 $q$。</li>\n<li>现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$，要么不是。</li>\n<li>如果 $len(p)+1=len(q)$，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。</li>\n<li>否则就会有些复杂。需要<strong>复制</strong>状态 $q$：我们创建一个新的状态 $clone$，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$。<br>复制之后，我们将后缀链接从 $cur$ 指向 $clone$，也从 $q$ 指向 $clone$。<br>最终我们需要使用后缀链接从状态 $p$ 返回，因为存在一条通过 $c$ 到状态 $q$ 的转移，并在此过程中重定向所有状态到状态 $clone$。</li>\n<li>以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$。</li>\n</ul>\n<p>如果我们还想知道哪些状态是<strong>终止状态</strong>而哪些不是，我们可以在为字符串 $s$ 构造完完整的后缀自动机后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会精确地标记字符串 $s$ 的所有后缀，这些状态恰好是终止状态。</p>\n<p>在下一部分，我们将观察算法每一步的细节，并证明它的<strong>正确性</strong>。</p>\n<p>现在，我们只注意到，因为我们只为 $s$ 的每个字符创建一个或两个新状态所以后缀自动机只包含<strong>线性个</strong>状态。</p>\n<p>转移个数是线性规模的，以及总体上算法的运行时间是线性规模的，这两点还不那么清<br>楚。</p>\n<h3 id=\"正确性证明\"><a href=\"#正确性证明\" class=\"headerlink\" title=\"正确性证明\"></a>正确性证明</h3><ul>\n<li>若一个转移 $(p,\\,q)$ 满足 $len(p)+1=len(q)$ 则我们称这个转移是<strong>连续的</strong>。否则，即当 $len(p)+1&lt;len(q)$ 时，这个转移被称为<strong>不连续的</strong>。  从算法描述中可以看出，连续的和非连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，非连续的转移可能会改变（转移边的端点可能会改变）。</li>\n<li>为了避免引起歧义，我们记向后缀自动机中插入当前字符 $c$ 之前的字符串为 $s$。</li>\n<li>算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。</li>\n<li>在创建一个新的状态之后，我们会从对应于整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个从字符 $c$ 到新状态 $cur$ 的转移。然而我我们只能添加与原来已存在的转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。</li>\n<li>最简单的情况是我们到达了虚拟状态 $-1$，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$。</li>\n<li>第二种情况下，我们找到了现有的转移 $(p,\\,q)$。这意味着我们尝试向自动机内添加一个<strong>已经存在的</strong>字符串 $x+c$（其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。  然而，有一个难点。从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$，即这个状态的 $len$ 应该是 $len(p)+1$。然而还不存在这样的状态，即 $len(q)&gt;len(p)+1$。这种情况下，我们必须要通过拆开状态 $q$ 来创建一个这样的状态。</li>\n<li>如果转移 $(p,\\,q)$ 是连续的，那么 $len(q)=len(p)+1$。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$。</li>\n<li>否则转移是不连续的，即 $len(q)&gt;len(p)+1$，这意味着状态 $q$ 不只对应于长度为$len(p)+1$ 的后缀 $s+c$，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。<br>我们如何拆开一个状态呢？我们<strong>复制</strong>状态 $q$，产生一个状态 $clone$，我们将 $len(clone)$ 赋值为 $len(p)+1$。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$。<br>在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$。<br>最后一步我们将一些到 $q$ 转移重定向到 $clone$。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$（其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从顶点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。</li>\n</ul>\n<h3 id=\"对操作次数为线性的证明\"><a href=\"#对操作次数为线性的证明\" class=\"headerlink\" title=\"对操作次数为线性的证明\"></a>对操作次数为线性的证明</h3><p>首先我们假设字符集大小为<strong>常数</strong>。如果字符集大小不是常数，后缀自动机的时间复杂度就不是线性的。从一个顶点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $k$ 为字符集的大小，则算法的渐进时间复杂度为 $O(n\\log k)$，空间复杂度为 $O(n)$。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个顶点的转移存储为长度为 $k$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$，空间复杂度为 $O(nk)$。</p>\n<p>所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移—这些操作的时间复杂度都为 $O(1)$。</p>\n<p>如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：</p>\n<ul>\n<li>第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。</li>\n<li>第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。</li>\n<li>第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。</li>\n</ul>\n<p>我们使用后缀自动机的大小（状态数和转移数）为<strong>线性的</strong>的事实（对状态数是线性的的证明就是算法本身，对状态数为线性的的证明将在稍后实现算法后给出）。</p>\n<p>因此上述<strong>第一处和第二处</strong>的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。</p>\n<p>还需为<strong>第三处</strong>估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$。我们记 $v=longest(p)$，这是一个字符串 $s$ 的后缀，每次迭代长度都递减—因为作为字符串 $s$ 的位置随着每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$ $(k\\ge2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。</p>\n<p>因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>首先，我们描述一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将会用一个 <code>map</code> 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\\log k)$ 的时间复杂度内处理整个字符串。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">state</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len, link;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后缀自动机本身将会存储在一个 <code>state</code> 结构体数组中。我们记录当前自动机的大小 <code>sz</code> 和变量 <code>last</code>，当前整个字符串对应的状态。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXLEN = <span class=\"number\">100000</span>;</span><br><span class=\"line\">state st[MAXLEN * <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sz, last;</span><br></pre></td></tr></table></figure>\n<p>我们定义一个函数来初始化后缀自动机（创建一个只有一个状态的后缀自动机）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sa_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    st[<span class=\"number\">0</span>].len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    st[<span class=\"number\">0</span>].link = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    sz++;</span><br><span class=\"line\">    last = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终我们给出主函数的实现—给当前行末增加一个字符，对应地重建自动机。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sa_extend</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur = sz++;</span><br><span class=\"line\">    st[cur].len = st[last].len + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = last;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p != <span class=\"number\">-1</span> &amp;&amp; !st[p].next.count(c)) &#123;</span><br><span class=\"line\">        st[p].next[c] = cur;</span><br><span class=\"line\">        p = st[p].link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        st[cur].link = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q = st[p].next[c];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[p].len + <span class=\"number\">1</span> = st[q].len) &#123;</span><br><span class=\"line\">            st[cur].link = q;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> clone = sz++;</span><br><span class=\"line\">            st[clone].len = st[p].len + <span class=\"number\">1</span>;</span><br><span class=\"line\">            st[clone].next = st[q].next;</span><br><span class=\"line\">            st[clone].link = st[q].link;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"number\">-1</span> &amp;&amp; st[p].next[c] == q) &#123;</span><br><span class=\"line\">                st[p].next[c] = clone;</span><br><span class=\"line\">                p = st[p].link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st[q].link = st[cur].link = clone;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    last = cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(nk)$，其中 $k$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小 $k$ 任意的后缀自动机。但是这样你需要为每一个状态储存一个大小为 $k$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。</p>\n<h2 id=\"更多的性质\"><a href=\"#更多的性质\" class=\"headerlink\" title=\"更多的性质\"></a>更多的性质</h2><h3 id=\"状态数\"><a href=\"#状态数\" class=\"headerlink\" title=\"状态数\"></a>状态数</h3><p>对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的状态数<strong>不会超过 $2n-1$</strong> （假设 $n\\ge2$）。</p>\n<p>对上述结论的证明就是算法本身，因为一开始自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。</p>\n<p>然而我们也能在<strong>不知道这个算法</strong>的情况下<strong>展示</strong>这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。另外这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部顶点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部顶点的度数大于一的树，并且叶子节点的个数不超过 $n$。因此这样的树里有不超过 $2n-1$ 个节点。</p>\n<p>对于每个确定的 $n$，状态数的上界是确定的。一个可能的字符串是：</p>\n<p>$$<br><code></code>abbb\\ldots bbb!“<br>$$</p>\n<p>从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。</p>\n<h3 id=\"转移数\"><a href=\"#转移数\" class=\"headerlink\" title=\"转移数\"></a>转移数</h3><p>对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的转移数<strong>不会超过 $3n-4$</strong>（假设 $n\\ge 3$）。</p>\n<p>证明如下：</p>\n<p>我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的最长路径的生成树。生成树的骨架只包含连续的边，因此数量少于状态数，即，边数不会超过 $2n-2$。</p>\n<p>现在我们来估计非连续的转移的数量。令当前非连续转移为 $(p,\\,q)$，其字符为 $c$。我们取它的对应字符串 $u+c+w$，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径，$w$ 对应于从 $p$ 到任意终止状态的最长路径。一方面，对于每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$（因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$。</p>\n<p>将以上两个估计值结合起来，我们可以得到上界 $3n-3$。然而，最大的状态数只能在测试数据 $<code></code>abbb\\ldots bbb!“$ 中产生，这个测试数据的转移数量显然少于 $3n-3$，我们可以获得更为紧确的后缀自动机的转移数的上界：$3n-4$。</p>\n<p>上界可以通过字符串</p>\n<p>$$<br><code></code>abbb\\ldots bbbc!“<br>$$</p>\n<p>达到。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>下面我们来看一下一些可以用后缀自动机解决的问题。为了简单，我们假设字符集的大小 $k$ 为常数，允许我们认为增加一个字符和遍历的复杂度为常数。</p>\n<h3 id=\"检查字符串是否出现\"><a href=\"#检查字符串是否出现\" class=\"headerlink\" title=\"检查字符串是否出现\"></a>检查字符串是否出现</h3><blockquote>\n<p>给一个文本串 $T$ 和多个模式串 $P$，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。</p>\n</blockquote>\n<p>我们在 $O(length(T))$ 的时间内为文本串 $T$ 构造后缀自动机。为了检查模式串 $T$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$，那么模式串在 $T$ 中出现过。因此</p>\n<p>对于每个字符串 $P$ 算法的时间复杂度为 $O(length(P))$。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。</p>\n<h3 id=\"不同子串个数\"><a href=\"#不同子串个数\" class=\"headerlink\" title=\"不同子串个数\"></a>不同子串个数</h3><blockquote>\n<p>给一个字符串 $S$，计算不同子串的个数。</p>\n</blockquote>\n<p>为字符串 $S$ 构造后缀自动机。</p>\n<p>每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。</p>\n<p>考虑到后缀自动机为有向无环图，不同路径的条数可以使用动态规划计算。</p>\n<p>即，令 $d[v]$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程式：</p>\n<p>$$<br>d[v]=1+\\sum_{w:(v,\\,w,\\,c)\\in SA}d[w]<br>$$</p>\n<p>即，$d[v]$ 可以表示为所有 $v$ 的转移的末端的和。</p>\n<p>所以不同子串的个数为 $d[t_0]-1$（因为要去掉空子串）。</p>\n<p>总时间复杂度为：$O(length(S))$。</p>\n<h3 id=\"所有不同子串的总长度\"><a href=\"#所有不同子串的总长度\" class=\"headerlink\" title=\"所有不同子串的总长度\"></a>所有不同子串的总长度</h3><blockquote>\n<p>给定一个字符串 $S$，计算所有不同子串的总长度。</p>\n</blockquote>\n<p>本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d[v]$ 和它们的总长度 $ans[v]$。</p>\n<p>我们已经在上一题中介绍了如何计算 $d[v]$。$ans[v]$ 的值可以使用通过以下递推式计算：</p>\n<p>$$<br>ans[v]=\\sum_{w:(v,\\,w,\\,c)\\in DAWG}d[w]+ans[w]<br>$$</p>\n<p>我们取每个邻接顶点 $w$ 的答案，并加上 $d[w]$（因为从状态 $v$ 出发的子串都增加了一个字符）。</p>\n<p>算法的时间复杂度仍然是 $O(length(S))$。</p>\n<h3 id=\"字典序第-k-大子串\"><a href=\"#字典序第-k-大子串\" class=\"headerlink\" title=\"字典序第 k 大子串\"></a>字典序第 <script type=\"math/tex\">k</script> 大子串</h3><blockquote>\n<p>给定一个字符串 $S$。多组询问，每组询问给定一个数 $K_i$，查询所有子串中词典序第 $k$ 大的子串。</p>\n</blockquote>\n<p>解决这个问题的思路基于前两个问题的思路。字典序第 $k$ 大的子串对应于后缀自动机中字典序第 $k$ 大的路径。因此在计算每个状态的路径数后，我们可以很容易地从后缀自动机的根开始找到第 $k$ 大的路径。</p>\n<p>预处理的时间复杂度为 $O(length(S))$，单次查询的复杂度为 $O(length(ans)\\cdot k)$（其中 $ans$ 是查询的答案，$k$ 为字符集的大小）。</p>\n<h3 id=\"最小循环移位\"><a href=\"#最小循环移位\" class=\"headerlink\" title=\"最小循环移位\"></a>最小循环移位</h3><blockquote>\n<p>给定一个字符串 $S$。找出字典序最小的循环移位。</p>\n</blockquote>\n<p>我们为字符串 $S+S$ 构造后缀自动机。则后缀自动机本身将包含字符串 $S$ 的所有循环移位作为路径。</p>\n<p>所以问题简化为寻找最小的长度为 $length(S)$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。</p>\n<p>总的时间复杂度为 $O(length(S))$。</p>\n<h3 id=\"出现次数\"><a href=\"#出现次数\" class=\"headerlink\" title=\"出现次数\"></a>出现次数</h3><blockquote>\n<p>对于一个给定的文本串 $T$，有多组询问，每组询问给一个模式串 $P$，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。</p>\n</blockquote>\n<p>我们为文本串 $T$ 构造后缀自动机。</p>\n<p>接下来我们做以下的预处理：对于自动机中的每个状态 $v$，预处理值等于 $endpos(v)$ 这个集合大小的 $cnt[v]$。事实上对应于同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。</p>\n<p>然而我们不能明确的构造集合 $endpos$，因此我们只考虑它们的大小 $cnt$。</p>\n<p>为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$），我们用 $cnt=1$ 初始化它。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt[v]$ 的值加到后缀链接上，即：</p>\n<p>$$<br>cnt[link(v)]+=cnt[v]<br>$$</p>\n<p>这样做每个状态的答案都是正确的。</p>\n<p>为什么这是正确的？通过复制获得的状态，恰好是 $length(T)$，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$，其它状态的 $cnt$ 值赋为 $0$。</p>\n<p>接下来我们对每一个 $v$ 执行以下操作：$cnt[link(v)]+=cnt[v]$。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt[v]$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt[v]$ 次。</p>\n<p>为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到<strong>一个</strong>其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。</p>\n<p>因此，我们可以在 $O(length(T))$ 的时间内计算出所有状态的 $cnt$ 的值。</p>\n<p>最后回答询问只需要查找查找值 $cnt[t]$，其中 $t$ 为如果存在这样的状态就是状态对应的模式串，如果不存在答案就为 $0$。单次查询的时间复杂度为 $O(length(P))$。</p>\n<h3 id=\"第一次出现的位置\"><a href=\"#第一次出现的位置\" class=\"headerlink\" title=\"第一次出现的位置\"></a>第一次出现的位置</h3><blockquote>\n<p>给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）。</p>\n</blockquote>\n<p>我们再构造一个后缀自动机。我们对自动机中的所有状态预处理位置 $firstpos$。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。</p>\n<p>为了维护 $firstpos$ 这些位置，我们将原函数扩展为 <code>sa_extend()</code>。当我们创建新状态 $cur$ 时，我们令：</p>\n<p>$$<br>firstpos(cur)=len(cur)-1<br>$$</p>\n<p>；当我们将顶点 $q$ 复制到 $clone$ 时，我们令：</p>\n<p>$$<br>firstpos(clone)=firstpos(q)<br>$$</p>\n<p>（因为值的唯一其它选项 $firstpos(cur)$ 肯定太大了）。</p>\n<p>那么查询的答案就是 $firstpos(t)-length(P)+1$，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(length(P))$ 的时间。</p>\n<h3 id=\"所有出现的位置\"><a href=\"#所有出现的位置\" class=\"headerlink\" title=\"所有出现的位置\"></a>所有出现的位置</h3><blockquote>\n<p>问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。</p>\n</blockquote>\n<p>我们还是为文本串 $T$ 构造后缀自动机。与上一个问题相似地，我们为所有状态计算位置 $firstpos$。</p>\n<p>如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。</p>\n<p>因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。</p>\n<p>这种变通方案的时间复杂度为 $O(answer(P))$，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。</p>\n<p>我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。</p>\n<p>此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 <code>is_clone</code>，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。</p>\n<p>以下是实现的框架：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">state</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_clone;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first_pos;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; inv_link;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在构造后缀自动机后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v = <span class=\"number\">1</span>; v &lt; sz; v++) &#123;</span><br><span class=\"line\">    st[st[v].link].inv_link.push_back(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出所有出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output_all_occurrences</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> P_length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!st[v].is_clone)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; st[v].first_pos - P_length + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u : st[v].inv_link)</span><br><span class=\"line\">        output_all_occurrences(u, P_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最短的没有出现的字符串\"><a href=\"#最短的没有出现的字符串\" class=\"headerlink\" title=\"最短的没有出现的字符串\"></a>最短的没有出现的字符串</h3><blockquote>\n<p>给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。</p>\n</blockquote>\n<p>我们在字符串 $S$ 的后缀自动机上做动态规划。</p>\n<p>令 $d[v]$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$，想找到不连续的转移需要添加的最小字符数量。计算 $d[v]$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d[v]=1$。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：</p>\n<p>$$<br>d[v]=1+\\min_{w(v,\\,w,\\,c)\\in SA}d[w]<br>$$</p>\n<p>问题的答案就是 $d[t_0]$，字符串可以通过计算过的数组 $d[]$ 逆推回去。</p>\n<h3 id=\"两个字符串的最长公共子串\"><a href=\"#两个字符串的最长公共子串\" class=\"headerlink\" title=\"两个字符串的最长公共子串\"></a>两个字符串的最长公共子串</h3><blockquote>\n<p>给定两个字符串 $S$ 和 $T$，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$。</p>\n</blockquote>\n<p>我们为字符串 $S$ 构造后缀自动机。</p>\n<p>我们现在处理字符串 $T$，对于每一个前缀都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。</p>\n<p>为了达到这一目的，我们使用两个变量，<strong>当前状态</strong> $v$ 和 <strong>当前长度</strong> $l$。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。</p>\n<p>一开始 $v=t_0$ 且 $l=0$，即，匹配为空串。</p>\n<p>现在我们来描述如何添加一个字符 $T[i]$ 并为其重新计算答案：</p>\n<ul>\n<li>如果存在一个从 $v$ 到字符 $T[i]$ 的转移，我们只需要转移并让 $l$ 自增一。</li>\n<li>如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照以下后缀链接进行转移：  </li>\n</ul>\n<p>$$<br>v=link(v)<br>$$</p>\n<p>   与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。</p>\n<ul>\n<li>如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$，直到我们找到一个转移或到达虚拟状态 $-1$（这意味着字符 $T[i]$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$）。</li>\n</ul>\n<p>问题的答案就是所有 $l$ 的最大值。</p>\n<p>这一部分的时间复杂度为 $O(length(T))$，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。</p>\n<p>代码实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">lcs</span> <span class=\"params\">(<span class=\"built_in\">string</span> S, <span class=\"built_in\">string</span> T)</span> </span>&#123;</span><br><span class=\"line\">    sa_init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S.size(); i++)</span><br><span class=\"line\">        sa_extend(S[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, best = <span class=\"number\">0</span>, bestpos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v &amp;&amp; !st[v].next.count(T[i])) &#123;</span><br><span class=\"line\">            v = st[v].link ;</span><br><span class=\"line\">            l = st[v].length ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[v].next.count(T[i])) &#123;</span><br><span class=\"line\">            v = st [v].next[T[i]];</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; best) &#123;</span><br><span class=\"line\">            best = l;</span><br><span class=\"line\">            bestpos = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.substr(bestpos - best + <span class=\"number\">1</span>, best);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多个字符串间的最长公共子串\"><a href=\"#多个字符串间的最长公共子串\" class=\"headerlink\" title=\"多个字符串间的最长公共子串\"></a>多个字符串间的最长公共子串</h3><blockquote>\n<p>给定 $k$ 个字符串 $S_i$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$。</p>\n</blockquote>\n<p>我们将所有的子串连接成一个较长的字符串 $T$，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：</p>\n<p>$$<br>T=S_1+D_1+S_2+D_2+\\cdots+S_k+D_k.<br>$$</p>\n<p>然后为字符串 $T$ 构造后缀自动机。</p>\n<p>现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则后缀自动机中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\\,\\ldots,\\,D_{j-1},\\,D_{j+1},\\,\\ldots,\\,D_k$ 开始的路径。</p>\n<p>因此我们需要计算可达性，它告诉我们对于自动机中的每个状态和每个字符 $D_i$ 是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 与动态规划计算。在此之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><ul>\n<li>SPOJ #7258 SUBLEX</li>\n<li><a href=\"http://hihocoder.com/problemset/problem/1441\" target=\"_blank\" rel=\"noopener\">HihoCoder #1441 : 后缀自动机一 · 基本概念</a></li>\n</ul>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><p>我们先给出与后缀自动机有关的最初的一些文献：</p>\n<ul>\n<li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. <strong>Linear<br>  Size Finite Automata for the Set of All Subwords of a Word. An Outline of<br>  Results</strong> [1983]</li>\n<li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. <strong>The Smallest Automaton<br>  Recognizing the Subwords of a Text</strong> [1984]</li>\n<li>Maxime Crochemore. <strong>Optimal Factor Transducers</strong> [1985]</li>\n<li>Maxime Crochemore. <strong>Transducers and Repetitions</strong> [1986]</li>\n<li>A. Nerode. <strong>Linear automaton transformations</strong> [1958]</li>\n</ul>\n<p>另外，在更新的一些资源里，在很多关于字符串算法的书中，都能找到这个主题：</p>\n<ul>\n<li>Maxime Crochemore, Rytter Wowjcieh. <strong>Jewels of Stringology</strong> [2002]</li>\n<li>Bill Smyth. <strong>Computing Patterns in Strings</strong> [2003]</li>\n<li>Bill Smith. <strong>Methods and algorithms of calculations on lines</strong> [2006]</li>\n</ul>\n<p>另外，还有一些资料：</p>\n<ul>\n<li>《后缀自动机》，陈立杰。</li>\n<li>《后缀自动机在字典树上的拓展》，刘研绎。</li>\n<li>《后缀自动机及其应用》，张天扬。</li>\n<li><a href=\"https://www.cnblogs.com/zinthos/p/3899679.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zinthos/p/3899679.html</a></li>\n<li><a href=\"https://codeforces.com/blog/entry/20861\" target=\"_blank\" rel=\"noopener\">https://codeforces.com/blog/entry/20861</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25948077\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25948077</a></li>\n</ul>\n<hr>\n<p><strong>本页面主要译自博文<br><a href=\"http://e-maxx.ru/algo/suffix_automata\" target=\"_blank\" rel=\"noopener\">Суффиксный автомат</a> 与其英文翻译版 <a href=\"https://cp-algorithms.com/string/suffix-automaton.html\" target=\"_blank\" rel=\"noopener\">Suffix Automaton</a> 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong></p>\n","site":{"data":{}},"excerpt":"后缀自动机是一个能解决许多字符串相关问题的有力的数据结构。\n\n举个例子，字符串问题：\n\n * 在另一个字符串中搜索一个字符串的所有出现位置。\n * 计算给定的字符串中有多少个不同的子串。\n\n以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。\n\n直观上，字符串的后缀自动机可以理解为给定字符串的所有子串的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造后缀自动机的时间复杂度仅为 $O(n)$（这里我们将字符集的大小 $k$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\\log k)","more":"<p><strong>后缀自动机</strong>是一个能解决许多字符串相关问题的有力的数据结构。</p>\n<p>举个例子，字符串问题：</p>\n<ul>\n<li>在另一个字符串中搜索一个字符串的所有出现位置。</li>\n<li>计算给定的字符串中有多少个不同的子串。</li>\n</ul>\n<p>以上问题都可以在线性的时间复杂度内通过后缀自动机来实现。</p>\n<p>直观上，字符串的后缀自动机可以理解为给定字符串的<strong>所有子串</strong>的压缩形式。值得注意的事实是，后缀自动机将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造后缀自动机的时间复杂度仅为 $O(n)$（这里我们将字符集的大小 $k$ 看作常数，否则时间复杂度和空间复杂度均为 $O(n\\log k)$）。</p>\n<h2 id=\"后缀自动机的定义\"><a href=\"#后缀自动机的定义\" class=\"headerlink\" title=\"后缀自动机的定义\"></a>后缀自动机的定义</h2><p>给定字符串 $s$ 的后缀自动机是一个接受所有字符串 $s$ 的后缀的最小 <strong>DFA</strong>（确定性有限自动机或确定性有限状态自动机）。</p>\n<p>换句话说：</p>\n<ul>\n<li>后缀自动机是一张有向无环图。顶点被称作<strong>状态</strong>，边被称作状态间的<strong>转移</strong>。</li>\n<li>一个状态 $t_0$ 为<strong>初始状态</strong>，它必定为这张图的源点（其它各点均与 $t_0$ 联通）。</li>\n<li>每个<strong>转移</strong>都标有一些字母。从一个顶点出发的所有转移均<strong>不同</strong>。</li>\n<li>一个或多个状态为<strong>终止状态</strong>。如果我们从初始状态 $t_0$ 出发，最终转移到了一个终止状态，则路径上的所有转移连接起来一定是字符串 $s$ 的一个后缀。 $s$ 的每个后缀均可用一条从 $t_0$ 到一个终止状态的路径构成。</li>\n<li>后缀自动机是所有满足上述条件的自动机中顶点数最少的一个。</li>\n</ul>\n<h3 id=\"子串的性质\"><a href=\"#子串的性质\" class=\"headerlink\" title=\"子串的性质\"></a>子串的性质</h3><p>后缀自动机最简单和最重要的性质是，它包含关于字符串 $s$ 的所有子串的信息。任意从初始状态 $t_0$ 开始的路径，如果我们将转移路径上的标号写下来，都会形成 $s$ 的一个<strong>子串</strong>。反之每个 $s$ 的子串对应于从 $t_0$ 开始的某条路径。</p>\n<p>为了简化表达，我们将会说子串<strong>对应于</strong>一条路径（从 $t_0$ 开始且一些标号构成这个子串）。反过来我们说任意一条路径<strong>对应于</strong>它的标号构成的字符串。</p>\n<p>一条或多条路径可以到达一个状态，因此我们说一个状态对应于字符串的集合，这也对应于那些路径。</p>\n<h3 id=\"构造后缀自动机的实例\"><a href=\"#构造后缀自动机的实例\" class=\"headerlink\" title=\"构造后缀自动机的实例\"></a>构造后缀自动机的实例</h3><p>我们将会在这里展示一些简单的字符串的后缀自动机。</p>\n<p>我们用蓝色表示初始状态，用绿色表示终止状态。</p>\n<p>对于字符串 $s=<code></code>“$：</p>\n<p><img src=\"./SA.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>a!“$：</p>\n<p><img src=\"./SAa.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>aa!“$：</p>\n<p><img src=\"./SAaa.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>ab!“$：</p>\n<p><img src=\"./SAab.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>abb!“$：</p>\n<p><img src=\"./SAabb.pdf.svg\" alt=\"\"></p>\n<p>对于字符串 $s=<code></code>abbb!“$：</p>\n<p><img src=\"./SAabbb.pdf.svg\" alt=\"\"></p>\n<h2 id=\"在线性时间内构造后缀自动机\"><a href=\"#在线性时间内构造后缀自动机\" class=\"headerlink\" title=\"在线性时间内构造后缀自动机\"></a>在线性时间内构造后缀自动机</h2><p>在我们描述线性时间内构造后缀自动机的算法之前，我们需要引入几个对理解构造过程非常重要的新概念并简单证明。</p>\n<h3 id=\"结束位置-endpos\"><a href=\"#结束位置-endpos\" class=\"headerlink\" title=\"结束位置 endpos\"></a>结束位置 <script type=\"math/tex\">endpos</script></h3><p>考虑字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 的任意非空子串 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> ，我们记 <span><span class=\"MathJax_Preview\">endpos(t)</span><script type=\"math/tex\">endpos(t)</script></span> 为在字符串 <span><span class=\"MathJax_Preview\">s</span><script type=\"math/tex\">s</script></span> 中 <span><span class=\"MathJax_Preview\">t</span><script type=\"math/tex\">t</script></span> 的所有结束位置（假设对字符串中字符的编号从零开始）。例如，对于字符串 <span><span class=\"MathJax_Preview\"><code>abcbc\\!&quot;&lt;/span&gt;&lt;script type=&quot;math/tex&quot;&gt;</code>abcbc!“</span>，我们有 <span><span class=\"MathJax_Preview\">endpos(<code>bc\\!&quot;)=2,\\,4&lt;/span&gt;&lt;script type=&quot;math/tex&quot;&gt;endpos(</code>bc!“)=2,\\,4</span>。</span></span></p>\n\n<p>当两个子串 $t_1$ 与 $t_2$ 的末尾集合相等时我们称它们是 $endpos$ 等价的：即 $endpos(t_1)=endpos(t_2)$。这样所有字符串 $s$ 的非空子串都可以根据它们的 <strong>$endpos$</strong> 集合被分为几个<strong>等价类</strong>。</p>\n<p>显然，在后缀自动机中的每个状态对应于一个或多个 $endpos$ 相同的子串。换句话说，后缀自动机中的状态数等于所有子串的等价类的个数，加上初始状态。后缀自动机的状态个数等价于 $endpos$ 相同的一个或多个子串。</p>\n<p>我们稍后将会用这个假设介绍构造后缀自动机的算法。在那时我们将会发现，后缀自动机需要满足的所有性质，除了最小性以外都满足了。由 Nerode 定理我们可以得出最小性（这篇文章不会证明后缀自动机的最小性）。</p>\n<p>由 $endpos$ 的值我们可以得到一些重要结论：</p>\n<blockquote>\n<p><strong>引理 1：</strong>当且仅当字符串 $u$ 以 $w$ 的一个后缀的形式出现在字符串 $s$ 中时，两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）是 $endpos$ 等价的。</p>\n</blockquote>\n<p>引理显然成立。如果 $u$ 和 $v$ 的 $endpos$ 相同，则 $u$ 是 $w$ 的一个后缀，且只以 $s$ 中的一个 $w$ 的后缀的形式出现。且根据定义，如果 $u$ 为 $w$ 的一个后缀，且只以后缀的形式在 $s$ 中出现时，两个子串的 $endpos$ 值相等。</p>\n<blockquote>\n<p><strong>引理 2：</strong>考虑两个非空子串 $u$ 和 $w$（假设 $length(u)\\le length(w)$）。则它们的 $endpos$ 构成的集合要么完全没有交集，要么 $endpos(w)$ 是 $endpos(u)$ 的一个子集。并且这依赖于 $u$ 是否为 $w$ 的一个后缀。即：</p>\n<p>$$<br>\\begin{cases}<br> endpos(w)\\subseteq endpos(u)&amp;\\text{若 $u$ 为 $w$ 的一个后缀}\\<br> endpos(w)\\cap endpos(u)=\\emptyset&amp;\\text{另一种情况}\\<br>\\end{cases}<br>$$</p>\n</blockquote>\n<p>证明：如果集合 $endpos(u)$ 与 $endpos(w)$ 有至少一个公共元素，那么由于字符串 $u$ 与 $w$ 都在一个位置结束，即 $u$ 是 $w$ 的一个后缀。但是如果如此在每次 $w$ 出现的位置子串 $u$ 也会出现，这意味着 $endpos(w)$ 是 $endpos(u)$ 的一个子集。</p>\n<blockquote>\n<p><strong>引理 3：</strong>考虑一个 $endpos$ 等价类。将类中的所有子串按长度非递增的顺序排序。即每个子串都会比它前一个子串短，与此同时每个子串也是它前一个子串的一个后缀。换句话说，同一等价类中的所有子串均互为后缀，且子串的长度恰好覆盖整个区间 $[x,\\,y]$。</p>\n</blockquote>\n<p>证明：固定一些 $endpos$ 等价类。如果等价类中只包含一个子串，引理显然成立。现在我们来讨论子串元素个数大于 $1$ 的等价类。</p>\n<p>由引理 1，两个不同的 $endpos$ 等价字符串中较短的一个总是较长的一个的真后缀。因此，等价类中不可能有两个等长的字符串。</p>\n<p>记 $w$ 为等价类中最长的字符串，类似地，记 $u$ 为等价类中最短的字符串。由引理 1，字符串 $u$ 是字符串 $w$ 的真后缀。现在考虑长度在区间 $[length(u),\\,length(w)]$ 中的 $w$ 的任意后缀。容易看出，这个后缀也在同一等价类中。因为这个后缀只能在字符串 $s$ 中以 $w$ 的一个后缀的形式存在（也因为较短的后缀 $u$ 在 $s$ 中只以 $w$ 的后缀的形式存在）。因此，由引理 1，这个后缀与字符串 $w$ $endpos$ 等价。</p>\n<h3 id=\"后缀链接-link\"><a href=\"#后缀链接-link\" class=\"headerlink\" title=\"后缀链接 link\"></a>后缀链接 <script type=\"math/tex\">link</script></h3><p>考虑后缀自动机中满足 $v\\ne t_0$ 的一些状态。我们已经知道，状态 $v$ 对应于具有相同 $endpos$ 的等价类。我们如果定义 $w$ 为这些字符串中最长的一个，则所有其它的字符串都是 $w$ 的后缀。</p>\n<p>我们还知道字符串 $w$ 的前几个后缀（如果我们用长度降序考虑这些后缀）在这个等价类中全部被包含，且所有其它后缀（至少一个—空后缀）在其它的等价类中。我们记 $t$ 为最大的这样的后缀，然后用后缀链接连到 $t$ 上。</p>\n<p>换句话说，一个<strong>后缀链接</strong> $link(v)$ 连接到对应于 $w$ 的最长后缀的另一个 $endpos$ 等价类的状态。</p>\n<p>以下我们假设初始状态 $t_0$ 对应于它自己这个等价类（只包含一个空字符串），为了方便我们规定 $endpos(t)={-1,\\,0,\\,\\ldots,\\,length(s)-1}$。</p>\n<blockquote>\n<p><strong>引理 4：</strong>所有后缀链接构成一棵根节点为 $t_0$ 的树。</p>\n</blockquote>\n<p>证明：考虑任意满足 $v\\ne t_0$ 的状态，一个后缀链接 $link(v)$ 连接到的状态对应于严格更短的字符串（根据后缀链接的定义和引理 3）。因此，通过在后缀链接上移动，我们早晚会到达对应空串的初始状态 $t_0$。</p>\n<blockquote>\n<p><strong>引理 5：</strong>如果我们使用集合 $endpos$ 构造一棵树（所有子节点的集合为父节点的子集），则这个结构由后缀链接连接起来。</p>\n</blockquote>\n<p>证明：由引理 2，我们可以用 $endpos$ 集合构造一棵树（因为两个集合要么完全没有交集要么互为子集）。</p>\n<p>我们现在考虑任意满足 $v\\ne t_0$ 的状态和它的后缀链接 $link(v)$，由后缀链接和引理 2，我们可以得到</p>\n<p>$$<br>endpos(v)\\subseteq endpos(link(v))<br>$$</p>\n<p>，这与前面的引理证明了以下断言成立：后缀链接构成的树本质上是 $endpos$ 集合构成的一棵树。</p>\n<p>以下是对于字符串 $<code></code>abcbc!“$ 构造后缀自动机时产生的后缀链接树的一个<strong>例子</strong>，节点被标记为对应等价类中最长的子串。</p>\n<p><img src=\"./SA_suffix_links.pdf.svg\" alt=\"\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在学习算法本身前，我们对之前学过的知识进行一下总结，并引入一些辅助记号。</p>\n<ul>\n<li>$s$ 的子串可以根据它们结束的位置 $endpos$ 被划分为多个等价类；</li>\n<li>后缀自动机由初始状态 $t_0$ 和与每一个 $endpos$ 等价类对应的每个状态组成；</li>\n<li>对于每一个状态 $v$，一个或多个子串与之匹配。我们记 $longest(v)$ 为其中最长的一个字符串，记 $len(v)$ 为它的长度。类似地，记 $shortest(v)$ 为最短的子串，它的长度为 $minlen(v)$。那么所有对应这个状态的所有字符串都是字符串 $longest(v)$ 的不同的后缀，且所有字符串的长度恰好覆盖区间 $[minlength(v),\\,len(v)]$ 中的每一个整数。</li>\n<li>对于任意满足 $v\\ne t_0$ 的状态，定义后缀链接为连接到对应字符串 $longest(v)$ 的长度为 $minlen(v)-1$ 的后缀的一条边。从根节点 $t_0$ 出发的后缀链接可以形成一棵树，与此同时，这棵树形成了 $endpos$ 集合间的包含关系。</li>\n<li>我们可以对 $v\\ne t_0$ 的状态使用后缀链接 $link(v)$ 解释 $minlen(v)$ 如下：</li>\n</ul>\n<p>$$<br>minlen(v)=len(link(v))+1.<br>$$</p>\n<ul>\n<li>如果我们从任意状态 $v_0$ 开始顺着后缀链接遍历，早晚都会到达初始状态 $t_0$。这种情况下我们可以得到一个互不相交的区间 $[minlen(v_i),\\,len(v_i)]$ 的序列，且它们的并集形成了连续的区间 $[0,\\,len(v_0)]$。</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>现在我们可以学习算法本身了。这个算法是<strong>在线</strong>算法，这意味着我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护后缀自动机。</p>\n<p>为了保证线性的空间复杂度，我们将只保存 $len$ 和 $link$ 的值和每个状态的一个转移列表，我们不会标记终止状态（但是我们稍后会展示在构造后缀自动机后如何分配这些标记）。</p>\n<p>一开始后缀自动机只包含一个状态 $t_0$，编号为 $0$（其它状态的编号为 $1,\\,2,\\,\\ldots$）。为了方便，我们分配给它 $len=0$ 和 $link=-1$（$-1$ 表示一个虚拟的不存在的状态）。</p>\n<p>现在整个任务转化为实现给当前字符串添加一个字符 $c$ 的过程。算法流程如下：</p>\n<ul>\n<li>令 $last$ 为对应添加字符 $c$ 之前的整个字符串（一开始我们设置 $last=0$ 且我们会在算法的最后一步对应地更新 $last$）。</li>\n<li>创建一个新的状态 $cur$，并将 $len(cur)$ 赋值为 $len(last)+1$，在这时 $link(cur)$ 的值还未知。</li>\n<li>现在我们按以下流程进行：我们从状态 $last$ 开始。如果还没有到字符 $c$ 的转移，我们就添加一个到状态 $cur$ 的转移，遍历后缀链接。如果在某个点已经存在到字符 $c$ 的后缀链接，我们就停下来，并将这个状态标记为 $p$。</li>\n<li>如果没有找到这样的状态 $p$，我们就到达了虚拟状态 $-1$，我们将 $link(cur)$ 赋值为 $-1$ 并退出。</li>\n<li>假设现在我们找到了一个状态 $p$，其可以转移到字符 $c$，我们将这个状态转移到的状态标记为 $q$。</li>\n<li>现在我们分类讨论两种状态，要么 $len(p) + 1 = len(q)$，要么不是。</li>\n<li>如果 $len(p)+1=len(q)$，我们只要将 $link(cur)$ 赋值为 $q$ 并退出。</li>\n<li>否则就会有些复杂。需要<strong>复制</strong>状态 $q$：我们创建一个新的状态 $clone$，复制 $q$ 的除了 $len$ 的值以外的所有信息（后缀链接和转移）。我们将 $len(clone)$ 赋值为 $len(p)+1$。<br>复制之后，我们将后缀链接从 $cur$ 指向 $clone$，也从 $q$ 指向 $clone$。<br>最终我们需要使用后缀链接从状态 $p$ 返回，因为存在一条通过 $c$ 到状态 $q$ 的转移，并在此过程中重定向所有状态到状态 $clone$。</li>\n<li>以上三种情况，在完成这个过程之后，我们将 $last$ 的值更新为状态 $cur$。</li>\n</ul>\n<p>如果我们还想知道哪些状态是<strong>终止状态</strong>而哪些不是，我们可以在为字符串 $s$ 构造完完整的后缀自动机后找到所有的终止状态。为此，我们从对应整个字符串的状态（存储在变量 $last$ 中），遍历它的后缀链接，直到到达初始状态。我们将所有遍历到的节点都标记为终止节点。容易理解这样做我们会精确地标记字符串 $s$ 的所有后缀，这些状态恰好是终止状态。</p>\n<p>在下一部分，我们将观察算法每一步的细节，并证明它的<strong>正确性</strong>。</p>\n<p>现在，我们只注意到，因为我们只为 $s$ 的每个字符创建一个或两个新状态所以后缀自动机只包含<strong>线性个</strong>状态。</p>\n<p>转移个数是线性规模的，以及总体上算法的运行时间是线性规模的，这两点还不那么清<br>楚。</p>\n<h3 id=\"正确性证明\"><a href=\"#正确性证明\" class=\"headerlink\" title=\"正确性证明\"></a>正确性证明</h3><ul>\n<li>若一个转移 $(p,\\,q)$ 满足 $len(p)+1=len(q)$ 则我们称这个转移是<strong>连续的</strong>。否则，即当 $len(p)+1&lt;len(q)$ 时，这个转移被称为<strong>不连续的</strong>。  从算法描述中可以看出，连续的和非连续的转移是算法的不同情况。连续的转移是固定的，我们不会再改变了。与此相反，当向字符串中插入一个新的字符时，非连续的转移可能会改变（转移边的端点可能会改变）。</li>\n<li>为了避免引起歧义，我们记向后缀自动机中插入当前字符 $c$ 之前的字符串为 $s$。</li>\n<li>算法从创建一个新状态 $cur$ 开始，对应于整个字符串 $s+c$。我们创建一个新的节点的原因很清楚。与此同时我们也创建了一个新的字符和一个新的等价类。</li>\n<li>在创建一个新的状态之后，我们会从对应于整个字符串 $s$ 的状态通过后缀链接进行遍历。对于每一个状态，我们尝试添加一个从字符 $c$ 到新状态 $cur$ 的转移。然而我我们只能添加与原来已存在的转移不冲突的转移。因此我们只要找到已存在的 $c$ 的转移，我们就必须停止。</li>\n<li>最简单的情况是我们到达了虚拟状态 $-1$，这意味着我们为所有 $s$ 的后缀添加了 $c$ 的转移。这也意味着，字符 $c$ 从未在字符串 $s$ 中出现过。因此 $cur$ 的后缀链接为状态 $0$。</li>\n<li>第二种情况下，我们找到了现有的转移 $(p,\\,q)$。这意味着我们尝试向自动机内添加一个<strong>已经存在的</strong>字符串 $x+c$（其中 $x$ 为 $s$ 的一个后缀，且字符串 $x+c$ 已经作为 $s$ 的一个子串出现过了）。因为我们假设字符串 $s$ 的自动机的构造是正确的，我们不应该在这里添加一个新的转移。  然而，有一个难点。从状态 $cur$ 出发的后缀链接应该连接到哪个状态呢？我们要把后缀链接连到一个状态上，且其中最长的一个字符串恰好是 $x+c$，即这个状态的 $len$ 应该是 $len(p)+1$。然而还不存在这样的状态，即 $len(q)&gt;len(p)+1$。这种情况下，我们必须要通过拆开状态 $q$ 来创建一个这样的状态。</li>\n<li>如果转移 $(p,\\,q)$ 是连续的，那么 $len(q)=len(p)+1$。在这种情况下一切都很简单。我们只需要将 $cur$ 的后缀链接指向状态 $q$。</li>\n<li>否则转移是不连续的，即 $len(q)&gt;len(p)+1$，这意味着状态 $q$ 不只对应于长度为$len(p)+1$ 的后缀 $s+c$，还对应于 $s$ 的更长的子串。除了将状态 $q$ 拆成两个子状态以外我们别无他法，所以第一个子状态的长度就是 $len(p)+1$ 了。<br>我们如何拆开一个状态呢？我们<strong>复制</strong>状态 $q$，产生一个状态 $clone$，我们将 $len(clone)$ 赋值为 $len(p)+1$。由于我们不想改变遍历到 $q$ 的路径，我们将 $q$ 的所有转移复制到 $clone$。我们也将从 $clone$ 出发的后缀链接设置为 $q$ 的后缀链接的目标，并设置 $q$ 的后缀链接为 $clone$。<br>在拆开状态后，我们将从 $cur$ 出发的后缀链接设置为 $clone$。<br>最后一步我们将一些到 $q$ 转移重定向到 $clone$。我们需要修改哪些转移呢？只重定向相当于所有字符串 $w+c$（其中 $w$ 是 $p$ 的最长字符串）的后缀就够了。即，我们需要继续沿着后缀链接遍历，从顶点 $p$ 直到虚拟状态 $-1$ 或者是转移到不是状态 $q$ 的一个转移。</li>\n</ul>\n<h3 id=\"对操作次数为线性的证明\"><a href=\"#对操作次数为线性的证明\" class=\"headerlink\" title=\"对操作次数为线性的证明\"></a>对操作次数为线性的证明</h3><p>首先我们假设字符集大小为<strong>常数</strong>。如果字符集大小不是常数，后缀自动机的时间复杂度就不是线性的。从一个顶点出发的转移存储在支持快速查询和插入的平衡树中。因此如果我们记 $k$ 为字符集的大小，则算法的渐进时间复杂度为 $O(n\\log k)$，空间复杂度为 $O(n)$。然而如果字符集足够小，可以不写平衡树，以空间换时间将每个顶点的转移存储为长度为 $k$ 的数组（用于快速查询）和链表（用于快速遍历所有可用关键字）。这样算法的时间复杂度为 $O(n)$，空间复杂度为 $O(nk)$。</p>\n<p>所以我们将认为字符集的大小为常数，即每次对一个字符搜索转移、添加转移、查找下一个转移—这些操作的时间复杂度都为 $O(1)$。</p>\n<p>如果我们考虑算法的各个部分，算法中有三处时间复杂度不明显是线性的：</p>\n<ul>\n<li>第一处是遍历所有状态 $last$ 的后缀链接，添加字符 $c$ 的转移。</li>\n<li>第二处是当状态 $q$ 被复制到一个新的状态 $clone$ 时复制转移的过程。</li>\n<li>第三处是修改指向 $q$ 的转移，将它们重定向到 $clone$ 的过程。</li>\n</ul>\n<p>我们使用后缀自动机的大小（状态数和转移数）为<strong>线性的</strong>的事实（对状态数是线性的的证明就是算法本身，对状态数为线性的的证明将在稍后实现算法后给出）。</p>\n<p>因此上述<strong>第一处和第二处</strong>的总复杂度显然为线性的，因为单次操作均摊只为自动机添加了一个新转移。</p>\n<p>还需为<strong>第三处</strong>估计总复杂度，我们将最初指向 $q$ 的转移重定向到 $clone$。我们记 $v=longest(p)$，这是一个字符串 $s$ 的后缀，每次迭代长度都递减—因为作为字符串 $s$ 的位置随着每次迭代都单调上升。这种情况下，如果在循环的第一次迭代之前，相对应的字符串 $v$ 在距离 $last$ 的深度为 $k$ $(k\\ge2)$ 的位置上（深度记为后缀链接的数量），那么在最后一次迭代后，字符串 $v+c$ 将会成为路径上第二个从 $cur$ 出发的后缀链接（它将会成为新的 $last$ 的值）。</p>\n<p>因此，循环中的每次迭代都会使作为当前字符串的后缀的字符串 $longest(link(link(last))$ 的位置单调递增。因此这个循环最多不会执行超过 $n$ 次迭代，这正是我们需要证明的。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>首先，我们描述一种存储一个转移的全部信息的数据结构。如果需要的话，你可以在这里加入一个终止标记，也可以是一些其它信息。我们将会用一个 <code>map</code> 存储转移的列表，允许我们在总计 $O(n)$ 的空间复杂度和 $O(n\\log k)$ 的时间复杂度内处理整个字符串。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">state</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len, link;</span><br><span class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>&gt; next;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>后缀自动机本身将会存储在一个 <code>state</code> 结构体数组中。我们记录当前自动机的大小 <code>sz</code> 和变量 <code>last</code>，当前整个字符串对应的状态。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXLEN = <span class=\"number\">100000</span>;</span><br><span class=\"line\">state st[MAXLEN * <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sz, last;</span><br></pre></td></tr></table></figure>\n<p>我们定义一个函数来初始化后缀自动机（创建一个只有一个状态的后缀自动机）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sa_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    st[<span class=\"number\">0</span>].len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    st[<span class=\"number\">0</span>].link = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    sz++;</span><br><span class=\"line\">    last = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终我们给出主函数的实现—给当前行末增加一个字符，对应地重建自动机。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sa_extend</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cur = sz++;</span><br><span class=\"line\">    st[cur].len = st[last].len + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = last;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p != <span class=\"number\">-1</span> &amp;&amp; !st[p].next.count(c)) &#123;</span><br><span class=\"line\">        st[p].next[c] = cur;</span><br><span class=\"line\">        p = st[p].link;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        st[cur].link = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> q = st[p].next[c];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[p].len + <span class=\"number\">1</span> = st[q].len) &#123;</span><br><span class=\"line\">            st[cur].link = q;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> clone = sz++;</span><br><span class=\"line\">            st[clone].len = st[p].len + <span class=\"number\">1</span>;</span><br><span class=\"line\">            st[clone].next = st[q].next;</span><br><span class=\"line\">            st[clone].link = st[q].link;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"number\">-1</span> &amp;&amp; st[p].next[c] == q) &#123;</span><br><span class=\"line\">                st[p].next[c] = clone;</span><br><span class=\"line\">                p = st[p].link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st[q].link = st[cur].link = clone;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    last = cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如之前提到的一样，如果你用内存换时间（空间复杂度为 $O(nk)$，其中 $k$ 为字符集大小），你可以在 $O(n)$ 的时间内构造字符集大小 $k$ 任意的后缀自动机。但是这样你需要为每一个状态储存一个大小为 $k$ 的数组（用于快速跳转到转移的字符），和另外一个所有转移的链表（用于快速在转移中迭代）。</p>\n<h2 id=\"更多的性质\"><a href=\"#更多的性质\" class=\"headerlink\" title=\"更多的性质\"></a>更多的性质</h2><h3 id=\"状态数\"><a href=\"#状态数\" class=\"headerlink\" title=\"状态数\"></a>状态数</h3><p>对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的状态数<strong>不会超过 $2n-1$</strong> （假设 $n\\ge2$）。</p>\n<p>对上述结论的证明就是算法本身，因为一开始自动机含有一个状态，第一次和第二次迭代中只会创建一个节点，剩余的 $n-2$ 步中每步会创建至多 $2$ 个状态。</p>\n<p>然而我们也能在<strong>不知道这个算法</strong>的情况下<strong>展示</strong>这个估计值。我们回忆一下状态数等于不同的 $endpos$ 集合个数。另外这些 $endpos$ 集合形成了一棵树（祖先节点的集合包含了它所有孩子节点的集合）。考虑将这棵树稍微变形一下：只要它有一个只有一个孩子的内部顶点（这意味着该子节点的集合至少遗漏了它的父集合中的一个位置），我们创建一个含有这个遗漏位置的集合。最后我们可以获得一棵每一个内部顶点的度数大于一的树，并且叶子节点的个数不超过 $n$。因此这样的树里有不超过 $2n-1$ 个节点。</p>\n<p>对于每个确定的 $n$，状态数的上界是确定的。一个可能的字符串是：</p>\n<p>$$<br><code></code>abbb\\ldots bbb!“<br>$$</p>\n<p>从第三次迭代后的每次迭代，算法都会拆开一个状态，最终产生恰好 $2n-1$ 个状态。</p>\n<h3 id=\"转移数\"><a href=\"#转移数\" class=\"headerlink\" title=\"转移数\"></a>转移数</h3><p>对于一个长度为 $n$ 的字符串 $s$，它的后缀自动机中的转移数<strong>不会超过 $3n-4$</strong>（假设 $n\\ge 3$）。</p>\n<p>证明如下：</p>\n<p>我们首先估计连续的转移的数量。考虑自动机中从状态 $t_0$ 开始的最长路径的生成树。生成树的骨架只包含连续的边，因此数量少于状态数，即，边数不会超过 $2n-2$。</p>\n<p>现在我们来估计非连续的转移的数量。令当前非连续转移为 $(p,\\,q)$，其字符为 $c$。我们取它的对应字符串 $u+c+w$，其中字符串 $u$ 对应于初始状态到 $p$ 的最长路径，$w$ 对应于从 $p$ 到任意终止状态的最长路径。一方面，对于每个不完整的字符串所对应的形如 $u+c+w$ 的字符串是不同的（因为字符串 $u$ 和 $w$ 仅由完整的转移组成）。另一方面，由终止状态的定义，每个形如 $u+c+w$ 的字符串都是整个字符串 $s$ 的后缀。因为 $s$ 只有 $n$ 个非空后缀，且形如 $u+c+w$ 的字符串都不包含 $s$（因为整个字符串只包含完整的转移），所以非完整的转移的总数不会超过 $n-1$。</p>\n<p>将以上两个估计值结合起来，我们可以得到上界 $3n-3$。然而，最大的状态数只能在测试数据 $<code></code>abbb\\ldots bbb!“$ 中产生，这个测试数据的转移数量显然少于 $3n-3$，我们可以获得更为紧确的后缀自动机的转移数的上界：$3n-4$。</p>\n<p>上界可以通过字符串</p>\n<p>$$<br><code></code>abbb\\ldots bbbc!“<br>$$</p>\n<p>达到。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>下面我们来看一下一些可以用后缀自动机解决的问题。为了简单，我们假设字符集的大小 $k$ 为常数，允许我们认为增加一个字符和遍历的复杂度为常数。</p>\n<h3 id=\"检查字符串是否出现\"><a href=\"#检查字符串是否出现\" class=\"headerlink\" title=\"检查字符串是否出现\"></a>检查字符串是否出现</h3><blockquote>\n<p>给一个文本串 $T$ 和多个模式串 $P$，我们要检查字符串 $P$ 是否作为 $T$ 的一个子串出现。</p>\n</blockquote>\n<p>我们在 $O(length(T))$ 的时间内为文本串 $T$ 构造后缀自动机。为了检查模式串 $T$ 是否在 $T$ 中出现，我们沿转移（边）从 $t_0$ 开始根据 $P$ 的字符进行转移。如果在某个点无法转移下去，则模式串 $P$ 不是 $T$ 的一个子串。如果我们能够这样处理完整个字符串 $P$，那么模式串在 $T$ 中出现过。因此</p>\n<p>对于每个字符串 $P$ 算法的时间复杂度为 $O(length(P))$。此外，这个算法还找到了模式串 $P$ 在文本串中出现的最大前缀长度。</p>\n<h3 id=\"不同子串个数\"><a href=\"#不同子串个数\" class=\"headerlink\" title=\"不同子串个数\"></a>不同子串个数</h3><blockquote>\n<p>给一个字符串 $S$，计算不同子串的个数。</p>\n</blockquote>\n<p>为字符串 $S$ 构造后缀自动机。</p>\n<p>每个 $S$ 的子串都相当于自动机中的一些路径。因此不同子串的个数等于自动机中以 $t_0$ 为起点的不同路径的条数。</p>\n<p>考虑到后缀自动机为有向无环图，不同路径的条数可以使用动态规划计算。</p>\n<p>即，令 $d[v]$ 为从状态 $v$ 开始的路径数量（包括长度为零的路径），则我们有如下递推方程式：</p>\n<p>$$<br>d[v]=1+\\sum_{w:(v,\\,w,\\,c)\\in SA}d[w]<br>$$</p>\n<p>即，$d[v]$ 可以表示为所有 $v$ 的转移的末端的和。</p>\n<p>所以不同子串的个数为 $d[t_0]-1$（因为要去掉空子串）。</p>\n<p>总时间复杂度为：$O(length(S))$。</p>\n<h3 id=\"所有不同子串的总长度\"><a href=\"#所有不同子串的总长度\" class=\"headerlink\" title=\"所有不同子串的总长度\"></a>所有不同子串的总长度</h3><blockquote>\n<p>给定一个字符串 $S$，计算所有不同子串的总长度。</p>\n</blockquote>\n<p>本题做法与上一题类似，只是现在我们需要考虑分两部分进行动态规划：不同子串的数量 $d[v]$ 和它们的总长度 $ans[v]$。</p>\n<p>我们已经在上一题中介绍了如何计算 $d[v]$。$ans[v]$ 的值可以使用通过以下递推式计算：</p>\n<p>$$<br>ans[v]=\\sum_{w:(v,\\,w,\\,c)\\in DAWG}d[w]+ans[w]<br>$$</p>\n<p>我们取每个邻接顶点 $w$ 的答案，并加上 $d[w]$（因为从状态 $v$ 出发的子串都增加了一个字符）。</p>\n<p>算法的时间复杂度仍然是 $O(length(S))$。</p>\n<h3 id=\"字典序第-k-大子串\"><a href=\"#字典序第-k-大子串\" class=\"headerlink\" title=\"字典序第 k 大子串\"></a>字典序第 <script type=\"math/tex\">k</script> 大子串</h3><blockquote>\n<p>给定一个字符串 $S$。多组询问，每组询问给定一个数 $K_i$，查询所有子串中词典序第 $k$ 大的子串。</p>\n</blockquote>\n<p>解决这个问题的思路基于前两个问题的思路。字典序第 $k$ 大的子串对应于后缀自动机中字典序第 $k$ 大的路径。因此在计算每个状态的路径数后，我们可以很容易地从后缀自动机的根开始找到第 $k$ 大的路径。</p>\n<p>预处理的时间复杂度为 $O(length(S))$，单次查询的复杂度为 $O(length(ans)\\cdot k)$（其中 $ans$ 是查询的答案，$k$ 为字符集的大小）。</p>\n<h3 id=\"最小循环移位\"><a href=\"#最小循环移位\" class=\"headerlink\" title=\"最小循环移位\"></a>最小循环移位</h3><blockquote>\n<p>给定一个字符串 $S$。找出字典序最小的循环移位。</p>\n</blockquote>\n<p>我们为字符串 $S+S$ 构造后缀自动机。则后缀自动机本身将包含字符串 $S$ 的所有循环移位作为路径。</p>\n<p>所以问题简化为寻找最小的长度为 $length(S)$ 的路径，这可以通过平凡的方法做到：我们从初始状态开始，贪心地访问最小的字符即可。</p>\n<p>总的时间复杂度为 $O(length(S))$。</p>\n<h3 id=\"出现次数\"><a href=\"#出现次数\" class=\"headerlink\" title=\"出现次数\"></a>出现次数</h3><blockquote>\n<p>对于一个给定的文本串 $T$，有多组询问，每组询问给一个模式串 $P$，回答模式串 $P$ 在字符串 $T$ 中作为子串出现了多少次。</p>\n</blockquote>\n<p>我们为文本串 $T$ 构造后缀自动机。</p>\n<p>接下来我们做以下的预处理：对于自动机中的每个状态 $v$，预处理值等于 $endpos(v)$ 这个集合大小的 $cnt[v]$。事实上对应于同一状态 $v$ 的所有子串在文本串 $T$ 中的出现次数相同，这相当于集合 $endpos$ 中的位置数。</p>\n<p>然而我们不能明确的构造集合 $endpos$，因此我们只考虑它们的大小 $cnt$。</p>\n<p>为了计算这些值，我们进行以下操作。对于每个状态，如果它不是通过复制创建的（且它不是初始状态 $t_0$），我们用 $cnt=1$ 初始化它。然后我们按它们的长度 $len$ 降序遍历所有状态，并将当前的 $cnt[v]$ 的值加到后缀链接上，即：</p>\n<p>$$<br>cnt[link(v)]+=cnt[v]<br>$$</p>\n<p>这样做每个状态的答案都是正确的。</p>\n<p>为什么这是正确的？通过复制获得的状态，恰好是 $length(T)$，并且它们中的前 $i$ 个在我们插入前 $i$ 个字符时产生。因此对于每个这样的状态，我们在它被处理时计算它们所对应的位置的数量。因此我们初始将这些状态的 $cnt$ 的值赋为 $1$，其它状态的 $cnt$ 值赋为 $0$。</p>\n<p>接下来我们对每一个 $v$ 执行以下操作：$cnt[link(v)]+=cnt[v]$。其背后的含义是，如果有一个字符串 $v$ 出现了 $cnt[v]$ 次，那么它的所有后缀也在完全相同的地方结束，即也出现了 $cnt[v]$ 次。</p>\n<p>为什么我们在这个过程中不会重复计数（即把某些位置数了两次）呢？因为我们只将一个状态的位置添加到<strong>一个</strong>其它的状态上，所以一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。</p>\n<p>因此，我们可以在 $O(length(T))$ 的时间内计算出所有状态的 $cnt$ 的值。</p>\n<p>最后回答询问只需要查找查找值 $cnt[t]$，其中 $t$ 为如果存在这样的状态就是状态对应的模式串，如果不存在答案就为 $0$。单次查询的时间复杂度为 $O(length(P))$。</p>\n<h3 id=\"第一次出现的位置\"><a href=\"#第一次出现的位置\" class=\"headerlink\" title=\"第一次出现的位置\"></a>第一次出现的位置</h3><blockquote>\n<p>给定一个文本串 $T$，多组查询。每次查询字符串 $P$ 在字符串 $T$ 中第一次出现的位置（$P$ 的开头位置）。</p>\n</blockquote>\n<p>我们再构造一个后缀自动机。我们对自动机中的所有状态预处理位置 $firstpos$。即，对每个状态 $v$ 我们想要找到第一次出现这个状态的末端的位置 $firstpos[v]$。换句话说，我们希望先找到每个集合 $endpos$ 中的最小的元素（显然我们不能显式地维护所有 $endpos$ 集合）。</p>\n<p>为了维护 $firstpos$ 这些位置，我们将原函数扩展为 <code>sa_extend()</code>。当我们创建新状态 $cur$ 时，我们令：</p>\n<p>$$<br>firstpos(cur)=len(cur)-1<br>$$</p>\n<p>；当我们将顶点 $q$ 复制到 $clone$ 时，我们令：</p>\n<p>$$<br>firstpos(clone)=firstpos(q)<br>$$</p>\n<p>（因为值的唯一其它选项 $firstpos(cur)$ 肯定太大了）。</p>\n<p>那么查询的答案就是 $firstpos(t)-length(P)+1$，其中 $t$ 为对应字符串 $P$ 的状态。单次查询只需要 $O(length(P))$ 的时间。</p>\n<h3 id=\"所有出现的位置\"><a href=\"#所有出现的位置\" class=\"headerlink\" title=\"所有出现的位置\"></a>所有出现的位置</h3><blockquote>\n<p>问题同上，这一次需要查询文本串 $T$ 中模式串出现的所有位置。</p>\n</blockquote>\n<p>我们还是为文本串 $T$ 构造后缀自动机。与上一个问题相似地，我们为所有状态计算位置 $firstpos$。</p>\n<p>如果 $t$ 为对应于模式串 $T$ 的状态，显然 $firstpos(t)$ 为答案的一部分。需要查找的其它位置怎么办？我们使用了含有字符串 $P$ 的自动机，我们还需要将哪些状态纳入自动机呢？所有对应于以 $P$ 为后缀的字符串的状态。换句话说我们要找到所有可以通过后缀链接到达状态 $t$ 的状态。</p>\n<p>因此为了解决这个问题，我们需要为每一个状态保存一个指向它的后缀引用列表。查询的答案就包含了对于每个我们能从状态 $t$ 只使用后缀引用进行 DFS 或 BFS 的所有状态的 $firstpos$ 值。</p>\n<p>这种变通方案的时间复杂度为 $O(answer(P))$，因为我们不会重复访问一个状态（因为对于仅有一个后缀链接指向一个状态，所以不存在两条不同的路径指向同一状态）。</p>\n<p>我们只需要考虑两个可能有相同 $endpos$ 值的不同状态。如果一个状态是由另一个复制而来的，则这种情况会发生。然而，这并不会对复杂度分析造成影响，因为每个状态至多被复制一次。</p>\n<p>此外，如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达。因此，如果我们给每个状态记录标记 <code>is_clone</code>，我们就可以简单地忽略掉被复制的状态，只输出其它所有状态的 $firstpos$ 的值。</p>\n<p>以下是实现的框架：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">state</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> is_clone;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first_pos;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; inv_link;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在构造后缀自动机后</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> v = <span class=\"number\">1</span>; v &lt; sz; v++) &#123;</span><br><span class=\"line\">    st[st[v].link].inv_link.push_back(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出所有出现位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output_all_occurrences</span><span class=\"params\">(<span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> P_length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!st[v].is_clone)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; st[v].first_pos - P_length + <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> u : st[v].inv_link)</span><br><span class=\"line\">        output_all_occurrences(u, P_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最短的没有出现的字符串\"><a href=\"#最短的没有出现的字符串\" class=\"headerlink\" title=\"最短的没有出现的字符串\"></a>最短的没有出现的字符串</h3><blockquote>\n<p>给定一个字符串 $S$ 和一个特定的字符集，我们要找一个长度最短的没有在 $S$ 中出现过的字符串。</p>\n</blockquote>\n<p>我们在字符串 $S$ 的后缀自动机上做动态规划。</p>\n<p>令 $d[v]$ 为节点 $v$ 的答案，即，我们已经处理完了子串的一部分，当前在状态 $v$，想找到不连续的转移需要添加的最小字符数量。计算 $d[v]$ 非常简单。如果不存在使用字符集中至少一个字符的转移，则 $d[v]=1$。否则添加一个字符是不够的，我们需要求出所有转移中的最小值：</p>\n<p>$$<br>d[v]=1+\\min_{w(v,\\,w,\\,c)\\in SA}d[w]<br>$$</p>\n<p>问题的答案就是 $d[t_0]$，字符串可以通过计算过的数组 $d[]$ 逆推回去。</p>\n<h3 id=\"两个字符串的最长公共子串\"><a href=\"#两个字符串的最长公共子串\" class=\"headerlink\" title=\"两个字符串的最长公共子串\"></a>两个字符串的最长公共子串</h3><blockquote>\n<p>给定两个字符串 $S$ 和 $T$，求出最长公共子串，公共子串定义为在 $S$ 和 $T$ 中都作为子串出现过的字符串 $X$。</p>\n</blockquote>\n<p>我们为字符串 $S$ 构造后缀自动机。</p>\n<p>我们现在处理字符串 $T$，对于每一个前缀都在 $S$ 中寻找这个前缀的最长后缀。换句话说，对于每个字符串 $T$ 中的位置，我们想要找到这个位置结束的 $S$ 和 $T$ 的最长公共子串的长度。</p>\n<p>为了达到这一目的，我们使用两个变量，<strong>当前状态</strong> $v$ 和 <strong>当前长度</strong> $l$。这两个变量描述当前匹配的部分：它的长度和它们对应的状态。</p>\n<p>一开始 $v=t_0$ 且 $l=0$，即，匹配为空串。</p>\n<p>现在我们来描述如何添加一个字符 $T[i]$ 并为其重新计算答案：</p>\n<ul>\n<li>如果存在一个从 $v$ 到字符 $T[i]$ 的转移，我们只需要转移并让 $l$ 自增一。</li>\n<li>如果不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照以下后缀链接进行转移：  </li>\n</ul>\n<p>$$<br>v=link(v)<br>$$</p>\n<p>   与此同时，需要缩短当前长度。显然我们需要将 $l$ 赋值为 $len(v)$，因为经过这个后缀链接后我们到达的状态所对应的最长字符串是一个子串。</p>\n<ul>\n<li>如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小 $l$，直到我们找到一个转移或到达虚拟状态 $-1$（这意味着字符 $T[i]$ 根本没有在 $S$ 中出现过，所以我们设置 $v=l=0$）。</li>\n</ul>\n<p>问题的答案就是所有 $l$ 的最大值。</p>\n<p>这一部分的时间复杂度为 $O(length(T))$，因为每次移动我们要么可以使 $l$ 增加一，要么可以在后缀链接间移动几次，每次都减小 $l$ 的值。</p>\n<p>代码实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">lcs</span> <span class=\"params\">(<span class=\"built_in\">string</span> S, <span class=\"built_in\">string</span> T)</span> </span>&#123;</span><br><span class=\"line\">    sa_init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; S.size(); i++)</span><br><span class=\"line\">        sa_extend(S[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> v = <span class=\"number\">0</span>, l = <span class=\"number\">0</span>, best = <span class=\"number\">0</span>, bestpos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; T.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v &amp;&amp; !st[v].next.count(T[i])) &#123;</span><br><span class=\"line\">            v = st[v].link ;</span><br><span class=\"line\">            l = st[v].length ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (st[v].next.count(T[i])) &#123;</span><br><span class=\"line\">            v = st [v].next[T[i]];</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; best) &#123;</span><br><span class=\"line\">            best = l;</span><br><span class=\"line\">            bestpos = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.substr(bestpos - best + <span class=\"number\">1</span>, best);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多个字符串间的最长公共子串\"><a href=\"#多个字符串间的最长公共子串\" class=\"headerlink\" title=\"多个字符串间的最长公共子串\"></a>多个字符串间的最长公共子串</h3><blockquote>\n<p>给定 $k$ 个字符串 $S_i$。我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串 $X$。</p>\n</blockquote>\n<p>我们将所有的子串连接成一个较长的字符串 $T$，以特殊字符 $D_i$ 分开每个字符串（一个字符对应一个字符串）：</p>\n<p>$$<br>T=S_1+D_1+S_2+D_2+\\cdots+S_k+D_k.<br>$$</p>\n<p>然后为字符串 $T$ 构造后缀自动机。</p>\n<p>现在我们需要在自动机中找到存在于所有字符串 $S_i$ 中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果 $S_j$ 包含了一个子串，则后缀自动机中存在一条从包含字符 $D_j$ 的子串而不包含以其它字符 $D_1,\\,\\ldots,\\,D_{j-1},\\,D_{j+1},\\,\\ldots,\\,D_k$ 开始的路径。</p>\n<p>因此我们需要计算可达性，它告诉我们对于自动机中的每个状态和每个字符 $D_i$ 是否存在这样的一条路径。这可以容易地通过 DFS 或 BFS 与动态规划计算。在此之后，问题的答案就是状态 $v$ 的字符串 $longest(v)$ 中存在所有特殊字符的路径。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><ul>\n<li>SPOJ #7258 SUBLEX</li>\n<li><a href=\"http://hihocoder.com/problemset/problem/1441\" target=\"_blank\" rel=\"noopener\">HihoCoder #1441 : 后缀自动机一 · 基本概念</a></li>\n</ul>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><p>我们先给出与后缀自动机有关的最初的一些文献：</p>\n<ul>\n<li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler, R. McConnell. <strong>Linear<br>  Size Finite Automata for the Set of All Subwords of a Word. An Outline of<br>  Results</strong> [1983]</li>\n<li>A. Blumer, J. Blumer, A. Ehrenfeucht, D. Haussler. <strong>The Smallest Automaton<br>  Recognizing the Subwords of a Text</strong> [1984]</li>\n<li>Maxime Crochemore. <strong>Optimal Factor Transducers</strong> [1985]</li>\n<li>Maxime Crochemore. <strong>Transducers and Repetitions</strong> [1986]</li>\n<li>A. Nerode. <strong>Linear automaton transformations</strong> [1958]</li>\n</ul>\n<p>另外，在更新的一些资源里，在很多关于字符串算法的书中，都能找到这个主题：</p>\n<ul>\n<li>Maxime Crochemore, Rytter Wowjcieh. <strong>Jewels of Stringology</strong> [2002]</li>\n<li>Bill Smyth. <strong>Computing Patterns in Strings</strong> [2003]</li>\n<li>Bill Smith. <strong>Methods and algorithms of calculations on lines</strong> [2006]</li>\n</ul>\n<p>另外，还有一些资料：</p>\n<ul>\n<li>《后缀自动机》，陈立杰。</li>\n<li>《后缀自动机在字典树上的拓展》，刘研绎。</li>\n<li>《后缀自动机及其应用》，张天扬。</li>\n<li><a href=\"https://www.cnblogs.com/zinthos/p/3899679.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zinthos/p/3899679.html</a></li>\n<li><a href=\"https://codeforces.com/blog/entry/20861\" target=\"_blank\" rel=\"noopener\">https://codeforces.com/blog/entry/20861</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25948077\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25948077</a></li>\n</ul>\n<hr>\n<p><strong>本页面主要译自博文<br><a href=\"http://e-maxx.ru/algo/suffix_automata\" target=\"_blank\" rel=\"noopener\">Суффиксный автомат</a> 与其英文翻译版 <a href=\"https://cp-algorithms.com/string/suffix-automaton.html\" target=\"_blank\" rel=\"noopener\">Suffix Automaton</a> 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong></p>\n"}],"PostAsset":[{"_id":"source/_posts/2018-9-21校内测试/pro.pdf","post":"cjmcms7j00000ns10uj1pf192","slug":"pro.pdf","modified":1,"renderable":1},{"_id":"source/_posts/perf/SA.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SA.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SA_suffix_links.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SA_suffix_links.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAa.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAa.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAaa.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAaa.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAab.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAab.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAaba.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAaba.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAabb.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAabb.pdf.svg","modified":1,"renderable":1},{"_id":"source/_posts/perf/SAabbb.pdf.svg","post":"cjmcms7jj0005ns10bikkasix","slug":"SAabbb.pdf.svg","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjmcms7j00000ns10uj1pf192","tag_id":"cjmcms7jg0004ns102oc7d89c","_id":"cjmcms7jm0006ns106r0yino8"}],"Tag":[{"name":"校内测试","_id":"cjmcms7jg0004ns102oc7d89c"}]}}