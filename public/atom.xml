<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QAQ</title>
  
  <subtitle>QAQ 哼唧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://funuuuu.github.io/"/>
  <updated>2018-09-28T00:47:03.130Z</updated>
  <id>https://funuuuu.github.io/</id>
  
  <author>
    <name>LizeWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「HDOJ-P3887」Counting Offspring</title>
    <link href="https://funuuuu.github.io/2018/09/28/%E3%80%8CHDOJ-P3887%E3%80%8DCounting-Offspring/"/>
    <id>https://funuuuu.github.io/2018/09/28/「HDOJ-P3887」Counting-Offspring/</id>
    <published>2018-09-28T00:45:30.000Z</published>
    <updated>2018-09-28T00:47:03.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><hr><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一棵树，和它的树根 $P$，并且节点从 $1\rightarrow n$ 编号，现在定义 $f(i)$ 为 $i$ 的子树中，节点编号小于 $i$ 的节点的个数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>有多组数据 (不超过 10 组)，对于每组数据：<br>第一行两个整数 $n,p$ $(n\le 10^5)$ 表示树有 $n$ 个节点，树根是 $p$。<br>接下来的 $n-1$ 行，每行两个整数，代表一条树边。<br>输入以两个零作为结束。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组测试数据，输出一行 $n$ 个整数 $f(1),f(2)……f(n)$，每两个数字之间以一个空格分格。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><hr><p>显然，我们想要求 $f(i)$ 的话，只需要对其子树进行统计，而有不能够每一次都去遍历一遍，那样一定会超时。我们可以用 dfs 序先对整棵树进行处理，dfs 序可以将一个点的子树的编号放在一个区间内。然后用线段树进行求解 (如果暴力的在区间内统计的话，会 TLE，实锤)，按编号从小到大将点的影响加到线段树中，边查询边更新。这样总时间复杂度是 $\text{O}(n\log n)$，显然可过。<br>要注意输出格式，每一行最后一个数字后面不能加空格。</p><h3 id="附上代码"><a href="#附上代码" class="headerlink" title="附上代码"></a>附上代码</h3><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) &#123;x = x*<span class="number">10</span> + c-<span class="string">'0'</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, head[maxn], Index, L[maxn], R[maxn], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ed[++cnt].nxt = head[x], ed[cnt].to = y, head[x] = cnt;</span><br><span class="line">ed[++cnt].nxt = head[y], ed[cnt].to = x, head[y] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fr)</span> </span>&#123;</span><br><span class="line">L[x] = ++ Index;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; i; i=ed[i].nxt) &#123;</span><br><span class="line"><span class="keyword">if</span>(ed[i].to == fr) <span class="keyword">continue</span>;</span><br><span class="line">dfs(ed[i].to, x);</span><br><span class="line">&#125;</span><br><span class="line">R[x] = Index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, sum;</span><br><span class="line">&#125;tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (k &lt;&lt; 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson ((k &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">tree[k].l = ll, tree[k].r = rr;</span><br><span class="line">tree[k].sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[k].l == tree[k].r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(Lson, ll, mid);</span><br><span class="line">build(Rson, mid+<span class="number">1</span>, rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> pos, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[k].l == tree[k].r &amp;&amp; tree[k].l == pos) &#123;</span><br><span class="line">tree[k].sum += num;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid) update(Lson, pos, num);</span><br><span class="line"><span class="keyword">else</span> update(Rson, pos, num);</span><br><span class="line">tree[k].sum = tree[Lson].sum + tree[Rson].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= tree[k].l &amp;&amp; r &gt;= tree[k].r)</span><br><span class="line"><span class="keyword">return</span> tree[k].sum;</span><br><span class="line"><span class="keyword">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) res += query(Lson, l, r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) res += query(Rson, l, r);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;rt) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; rt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">cnt = <span class="number">0</span>, Index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">x = read(), y = read();</span><br><span class="line">addedge(x, y);</span><br><span class="line">&#125;</span><br><span class="line">dfs(rt, <span class="number">0</span>);</span><br><span class="line">T.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, T.query(<span class="number">1</span>, L[i], R[i]));</span><br><span class="line">T.update(<span class="number">1</span>, L[i], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(i == n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      翻译



题目描述
给你一棵树，和它的树根 $P$，并且节点从 $1\rightarrow n$ 编号，现在定义 $f(i)$ 为 $i$ 的子树中，节点编号小于 $i$ 的节点的个数。

输入格式
有多组数据 (不超过 10 组)，对于每组数据：
第一行两个整数 $n,p$ $(n\le 10^5)$ 表示树有 $n$ 个节点，树根是 $p$。
接下来的 $n-1$ 行，每行两个整数，代表一条树边。
输入以两个零作为结束。

输出格式
对于每组测试数据，输出一行 $n$ 个整数 $f(1),f(2)……f(n)$，每两个数字之间以一个空格分格。

解题思路



显然，我们想要求 $f(i
    
    </summary>
    
    
      <category term="HDOJ" scheme="https://funuuuu.github.io/tags/HDOJ/"/>
    
      <category term="dfs序" scheme="https://funuuuu.github.io/tags/dfs%E5%BA%8F/"/>
    
      <category term="线段树" scheme="https://funuuuu.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu P3017」 布朗尼切片</title>
    <link href="https://funuuuu.github.io/2018/09/26/%E3%80%8CLuoguP3017%E3%80%8D%E5%B8%83%E6%9C%97%E5%B0%BC%E5%88%87%E7%89%87/"/>
    <id>https://funuuuu.github.io/2018/09/26/「LuoguP3017」布朗尼切片/</id>
    <published>2018-09-26T06:46:59.000Z</published>
    <updated>2018-09-26T06:49:29.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><hr><p>首先肯定是要二分答案的嘛，因为要最大化最小值啊。<br>那如何判断一个答案是否可行呢？<br>我们只需要先对一行进行判断，如果能将这一行分成大于等于 $mid$ (二分出来的答案) 的蛋糕 $B$ 块以上，就证明这一行可以单独劈成一条，如果不行的话，就和下一行一起放在一条中去判断，还不行的话就在加一行，观察一下，这样子分出来的条数是极限情况，也就是说，如果还不能分成大于等于 $A$ 条的话，那就不可能行了。反之，如果到最后大于等于 $A$ 条，那这个答案就是可行的。<br>中间的过程可以加入二维前缀和优化。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">503</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxn], n, m, arr[maxn][maxn], a, b;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) &#123;x = x*<span class="number">10</span> + c-<span class="string">'0'</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum[x2][y2] + sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>] - sum[x1<span class="number">-1</span>][y2] - sum[x2][y1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, tot = <span class="number">0</span>, now, r = <span class="number">1</span>, ff;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">now = <span class="number">1</span>, ff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line"><span class="keyword">if</span>(check(r, now, i, j) &gt;= mid)</span><br><span class="line">now = j+<span class="number">1</span>, ff ++;</span><br><span class="line"><span class="keyword">if</span>(ff &gt;= b) r = i+<span class="number">1</span>, tot++;</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot &gt;= a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read(), m = read(), a = read(), b = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> summ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">arr[i][j] = read();</span><br><span class="line">summ += arr[i][j];</span><br><span class="line">sum[i][j] += sum[i<span class="number">-1</span>][j] + summ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = sum[n][m], ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judge(mid)) l = mid+<span class="number">1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解题思路



首先肯定是要二分答案的嘛，因为要最大化最小值啊。
那如何判断一个答案是否可行呢？
我们只需要先对一行进行判断，如果能将这一行分成大于等于 $mid$ (二分出来的答案) 的蛋糕 $B$ 块以上，就证明这一行可以单独劈成一条，如果不行的话，就和下一行一起放在一条中去判断，还不行的话就在加一行，观察一下，这样子分出来的条数是极限情况，也就是说，如果还不能分成大于等于 $A$ 条的话，那就不可能行了。反之，如果到最后大于等于 $A$ 条，那这个答案就是可行的。
中间的过程可以加入二维前缀和优化。

代码



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
1
    
    </summary>
    
    
      <category term="Luogu" scheme="https://funuuuu.github.io/tags/Luogu/"/>
    
      <category term="二分答案" scheme="https://funuuuu.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="前綴和" scheme="https://funuuuu.github.io/tags/%E5%89%8D%E7%B6%B4%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu P2370」 yyy2015c01的U盘</title>
    <link href="https://funuuuu.github.io/2018/09/26/%E3%80%8CLuoguP2370%E3%80%8Dyyy2015c01%E7%9A%84U%E7%9B%98/"/>
    <id>https://funuuuu.github.io/2018/09/26/「LuoguP2370」yyy2015c01的U盘/</id>
    <published>2018-09-26T06:42:37.000Z</published>
    <updated>2018-09-26T06:47:56.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><hr><p>既然是最小化最大值，那就二分答案啊。<br>每次用0/1背包判断能否满足题目中给出的条件。那岂不是很简单喽。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> n, p, S;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIL</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w;</span><br><span class="line">&#125;fil[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=S; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(j &gt;= fil[i].w &amp;&amp; fil[i].w &lt;= mid)</span><br><span class="line">dp[j] = max(dp[j-fil[i].w] + fil[i].v, dp[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[S] &gt;= p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;p, &amp;S);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;fil[i].w, &amp;fil[i].v);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1000</span>, ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judge(mid)) r = mid<span class="number">-1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"No Solution!\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解题思路



既然是最小化最大值，那就二分答案啊。
每次用0/1背包判断能否满足题目中给出的条件。那岂不是很简单喽。

代码



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36


#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
using namespace std;
const int maxn = 1003;
int n, p, 
    
    </summary>
    
    
      <category term="Luogu" scheme="https://funuuuu.github.io/tags/Luogu/"/>
    
      <category term="二分答案" scheme="https://funuuuu.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="背包" scheme="https://funuuuu.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>「NOIp-2011」D2-T3 观光公交</title>
    <link href="https://funuuuu.github.io/2018/09/25/%E3%80%8CNOIp-2011%E3%80%8DD2-T3%E8%A7%82%E5%85%89%E5%85%AC%E4%BA%A4/"/>
    <id>https://funuuuu.github.io/2018/09/25/「NOIp-2011」D2-T3观光公交/</id>
    <published>2018-09-25T11:57:31.000Z</published>
    <updated>2018-09-25T12:18:12.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><hr><p>一开始自己想了一个贪心，虽然贪心的主要思路是对的，但并不会统计游客用的旅行时间。所以就去题解里面看看，第一篇是最小费用最大流，会比较麻烦，所以就去看了看底下的贪心，第一篇贪心被卡掉了，看第二篇，嗯，好像还行。再看看第三篇，写的好简略。不过看懂了。</p><p>贪心的主要思路就是在经过游客最多的路上使用加速器，但是还要注意，如果在一条路径的终点，有的游客到达的时间比现在公交车到达的时间还要晚的话就没必要用加速器了，因为再早到达你也必须等着游客上车吧。</p><p>考虑用优先队列保证得到最大的价值（经过的游客的数量），如果有一个点满足下面的条件：</p><p>最晚到达的乘客的到达时间比公交车的到达时间还要晚。</p><p>那就将整段路程从这里分开，分别去考虑劈开后的路程。</p><p>昨晚上面这些再来考虑如何处理每段路程。找一下这段路程中，每两个点之间的路途上，最短的等待时间，这就是要使用(用作用)的加速器数量的最大值。(因为超过了这个值就不会再有影响了)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) &#123;x = x*<span class="number">10</span> + c-<span class="string">'0'</span>; c = getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1003</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, tim, val;</span><br><span class="line">&#125;tmp;</span><br><span class="line"><span class="keyword">int</span> n, m, k, v[maxn], a[maxn], b[maxn], d[maxn], ans;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b) &#123;</span><br><span class="line"><span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(d[l] == <span class="number">0</span>) &#123;sol(l+<span class="number">1</span>, r); <span class="keyword">return</span> ;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>; i&lt;r; i++)</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt;= b[i]) &#123;</span><br><span class="line">sol(l, i), sol(i, r);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mn = d[l], val = v[r];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>; i&lt;r; i++) &#123;</span><br><span class="line">mn = min(mn, b[i]-a[i]);</span><br><span class="line">val += v[i];</span><br><span class="line">&#125;</span><br><span class="line">d[l] -= mn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l+<span class="number">1</span>; i&lt;r; i++) b[i] -= mn;</span><br><span class="line">Q.push((node)&#123;l, r, mn, val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read(), m = read(), k = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) d[i] = read();</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">z = read(), x = read(), y = read();</span><br><span class="line">a[x] = max(a[x], z);</span><br><span class="line">ans -= z;</span><br><span class="line">v[y] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) b[i] = max(b[i<span class="number">-1</span>], a[i<span class="number">-1</span>]) + d[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) ans += b[i] * v[i];</span><br><span class="line"><span class="keyword">for</span>(sol(<span class="number">1</span>, n); !Q.empty()&amp;&amp;k!=<span class="number">0</span>; ) &#123;</span><br><span class="line">tmp = Q.top(), Q.pop();</span><br><span class="line">ans -= min(tmp.tim, k) * tmp.val;</span><br><span class="line">k -= min(tmp.tim, k);</span><br><span class="line"><span class="keyword">if</span>(k != <span class="number">0</span>) sol(tmp.l, tmp.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解题思路



一开始自己想了一个贪心，虽然贪心的主要思路是对的，但并不会统计游客用的旅行时间。所以就去题解里面看看，第一篇是最小费用最大流，会比较麻烦，所以就去看了看底下的贪心，第一篇贪心被卡掉了，看第二篇，嗯，好像还行。再看看第三篇，写的好简略。不过看懂了。

贪心的主要思路就是在经过游客最多的路上使用加速器，但是还要注意，如果在一条路径的终点，有的游客到达的时间比现在公交车到达的时间还要晚的话就没必要用加速器了，因为再早到达你也必须等着游客上车吧。

考虑用优先队列保证得到最大的价值（经过的游客的数量），如果有一个点满足下面的条件：

最晚到达的乘客的到达时间比公交车的到达时间还要晚。

    
    </summary>
    
    
      <category term="Luogu" scheme="https://funuuuu.github.io/tags/Luogu/"/>
    
      <category term="NOIp" scheme="https://funuuuu.github.io/tags/NOIp/"/>
    
  </entry>
  
  <entry>
    <title>2018.9.21校内测试</title>
    <link href="https://funuuuu.github.io/2018/09/21/2018-9-21%E6%A0%A1%E5%86%85%E6%B5%8B%E8%AF%95/"/>
    <id>https://funuuuu.github.io/2018/09/21/2018-9-21校内测试/</id>
    <published>2018-09-21T13:36:42.000Z</published>
    <updated>2018-09-21T13:47:37.230Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="./pro.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="解题报告—9-21"><a href="#解题报告—9-21" class="headerlink" title="解题报告—9.21"></a>解题报告—9.21</h3><hr><h4 id="text-T1-相遇"><a href="#text-T1-相遇" class="headerlink" title="$\text{T1}$ 相遇"></a>$\text{T1}$ 相遇</h4><hr><h5 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h5><hr><p>T1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。</p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><hr><p>画几个图会发现 $a\rightarrow b,c\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\text{LCA}$ 在另两个点之间的路径上。</p><p>而一个点 $x$ 在一条路径 $s\rightarrow t$ 上的充要条件是如下：</p><ul><li>$depth[\text{LCA}(s,t)]\le depth[x]$</li><li>$\text{LCA}(x,s)=x \ ||\  \text{LCA}(x,t)=x$</li></ul><p>然后我们就可以做 $\text{LCA}$ 进行求解，一组数据最多询问 $4$ 次。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n, head[maxn], cnt, depth[maxn], T, fa[maxn][<span class="number">32</span>], m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to, nxt;</span><br><span class="line">&#125;ed[maxn], tmp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P100</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">tmp.to = tmp.nxt = <span class="number">0</span>;</span><br><span class="line">fill(ed+<span class="number">1</span>, ed+<span class="number">1</span>+maxn<span class="number">-3</span>, tmp);</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line"><span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ed[++cnt].nxt = head[x], head[x] = cnt, ed[cnt].to = y;</span><br><span class="line">ed[++cnt].nxt = head[y], head[y] = cnt, ed[cnt].to = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; <span class="number">1</span>&lt;&lt;j&lt;=n; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">fa[i][j] = fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=ed[i].nxt) &#123;</span><br><span class="line"><span class="keyword">if</span>(ed[i].to == fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">fa[ed[i].to][<span class="number">0</span>] = u;</span><br><span class="line">depth[ed[i].to] = depth[u] + <span class="number">1</span>;</span><br><span class="line">dfs(ed[i].to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[a] &gt; depth[b]) swap(a, b);</span><br><span class="line"><span class="keyword">int</span> h = depth[b] - depth[a];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; <span class="number">1</span>&lt;&lt;i&lt;=h; i++)</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;h) b = fa[b][i];</span><br><span class="line"><span class="keyword">if</span>(a != b) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)log2(n); i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span>(fa[a][i] != fa[b][i])</span><br><span class="line">a = fa[a][i], b = fa[b][i];</span><br><span class="line">&#125;</span><br><span class="line">a = fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = lca(a, b), y = lca(c, d);</span><br><span class="line"><span class="keyword">if</span>(depth[x] &lt; depth[y]) swap(x, y), swap(a, c), swap(b, d);</span><br><span class="line"><span class="keyword">if</span>(lca(x, c) == x || lca(x, d) == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p100;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"railway.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"railway.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">p100.reset();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">p100.addedge(x, y);</span><br><span class="line">&#125;</span><br><span class="line">p100.solve();</span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="keyword">if</span>(p100.judge(a, b, c, d)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="text-T2-计数"><a href="#text-T2-计数" class="headerlink" title="$\text{T2}$ 计数"></a>$\text{T2}$ 计数</h4><hr><h5 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h5><hr><p>不开 <code>long long</code> 见祖宗，写了个 $60$ 分的暴力，因为没开 <code>long long</code> 所以 WA 成了 30 分，以后做题先看好数据范围，可以为了以防万一，能开 <code>long long</code> 就开 <code>long long</code> 。</p><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><hr><p>在考场上写了个线段树维护区间最大最小值。然后 $N^2$ 枚举，左右端点，求和。算上查询的时间是 $\log N$ 总时间复杂度为 $N^2\log N$ 可以过 60 分。</p><p>再说正解：</p><p>题目大意可以简化为求下面这个式子的值：<br>$$<br>\sum_{r=1}^{n}\sum_{l=1}^{r}max(a[x]-a[y],l\le x,y\le r)<br>$$<br>观察上面的式子，其实可以从 $1\rightarrow n$ 算出每个数对答案的影响，相加就是答案。</p><p>那么怎么算贡献呢。用单调栈维护，一个点被弹出后就将其贡献减去，被压入后，就将其贡献加上。</p><p>求作为最大值的贡献和求作为最小值的贡献其实差不多，求最小值时将数组变成负数就又变成了求最大值的问题。</p><p>所以可以用一个函数解决。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><hr><p>60 分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">3</span>, inf = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL T, n, a[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">LL l, r, mx, mn;</span><br><span class="line">&#125;tree[<span class="number">400003</span>], tmp;</span><br><span class="line">LL ans_mn = inf, ans_mx;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P60</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tmp.l = tmp.r = tmp.mx = <span class="number">0</span>;</span><br><span class="line">tmp.mn = inf;</span><br><span class="line">fill(tree+<span class="number">1</span>, tree+<span class="number">400001</span>, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">tree[k].l = ll, tree[k].r = rr;</span><br><span class="line"><span class="keyword">if</span>(ll == rr) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[k].mn);</span><br><span class="line">tree[k].mx = tree[k].mn;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (ll + rr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(k &lt;&lt; <span class="number">1</span>, ll, mid);</span><br><span class="line">build((k &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, mid+<span class="number">1</span>, rr);</span><br><span class="line">tree[k].mx = max(tree[k&lt;&lt;<span class="number">1</span>].mx, tree[(k&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].mx);</span><br><span class="line">tree[k].mn = min(tree[k&lt;&lt;<span class="number">1</span>].mn, tree[(k&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[k].l &gt;= ll &amp;&amp; tree[k].r &lt;= rr) &#123;</span><br><span class="line">ans_mn = min(ans_mn, tree[k].mn);</span><br><span class="line">ans_mx = max(ans_mx, tree[k].mx);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (tree[k].l + tree[k].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid &gt;= ll) check(k &lt;&lt; <span class="number">1</span>, ll, rr);</span><br><span class="line"><span class="keyword">if</span>(mid &lt; rr) check((k&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, ll, rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">LL Ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=n; j++) &#123;</span><br><span class="line">ans_mx = <span class="number">0</span>, ans_mn = inf;</span><br><span class="line">check(<span class="number">1</span>, i, j);</span><br><span class="line">Ans += ans_mx - ans_mn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p60;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"count.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"count.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p60.solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>100 分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL s[maxn], n, a[maxn], T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P100</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL h = <span class="number">1</span>, t = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[s[t]]) sum -= a[s[t]] * (s[t]-s[t<span class="number">-1</span>]), t--;</span><br><span class="line">s[++t] = i;</span><br><span class="line">sum += a[i] * (i-s[t<span class="number">-1</span>]);</span><br><span class="line">ans += sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p100;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"count.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"count.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">LL ans = p100.solve();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) a[i] = -a[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans + p100.solve()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);</span><br><span class="line">fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解题报告—9.21



$\text{T1}$ 相遇



反思



T1 考到了 LCA，之前觉得没必要学，虽然也看过些文章，但大部分都没看懂，所以一直都不会，结果今天出上了这样的一道题，真尴尬，想着写写暴力吧，发现暴力也是求 LCA，无奈，遂放弃，考完试的下午就开始学 LCA，以后有能力学的东西尽量学学，不能老想着偷懒。

解题思路



画几个图会发现 $a\rightarrow b,c\rightarrow d$ 两条路径如果能够相交的话，需要满足其中一对点的 $\text{LCA}$ 在另两个点之间的路径上。

而一个点 $x$ 在一条路径 $s\rightarrow t$ 上的
    
    </summary>
    
    
      <category term="校内测试" scheme="https://funuuuu.github.io/tags/%E6%A0%A1%E5%86%85%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://funuuuu.github.io/2018/09/20/hello-world/"/>
    <id>https://funuuuu.github.io/2018/09/20/hello-world/</id>
    <published>2018-09-20T07:27:19.543Z</published>
    <updated>2018-09-19T23:38:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.

Quick Start
Create a new post
1


$ hexo new &quot;My New Post&quot;


More info: Writing

Run server
1


$ hexo s
    
    </summary>
    
    
  </entry>
  
</feed>
